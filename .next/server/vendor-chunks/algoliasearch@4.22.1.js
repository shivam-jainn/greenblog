"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/algoliasearch@4.22.1";
exports.ids = ["vendor-chunks/algoliasearch@4.22.1"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/algoliasearch@4.22.1/node_modules/algoliasearch/dist/algoliasearch-lite.esm.browser.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/algoliasearch@4.22.1/node_modules/algoliasearch/dist/algoliasearch-lite.esm.browser.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction createBrowserLocalStorageCache(options) {\n    const namespaceKey = `algoliasearch-client-js-${options.key}`;\n    // eslint-disable-next-line functional/no-let\n    let storage;\n    const getStorage = ()=>{\n        if (storage === undefined) {\n            storage = options.localStorage || window.localStorage;\n        }\n        return storage;\n    };\n    const getNamespace = ()=>{\n        return JSON.parse(getStorage().getItem(namespaceKey) || \"{}\");\n    };\n    const setNamespace = (namespace)=>{\n        getStorage().setItem(namespaceKey, JSON.stringify(namespace));\n    };\n    const removeOutdatedCacheItems = ()=>{\n        const timeToLive = options.timeToLive ? options.timeToLive * 1000 : null;\n        const namespace = getNamespace();\n        const filteredNamespaceWithoutOldFormattedCacheItems = Object.fromEntries(Object.entries(namespace).filter(([, cacheItem])=>{\n            return cacheItem.timestamp !== undefined;\n        }));\n        setNamespace(filteredNamespaceWithoutOldFormattedCacheItems);\n        if (!timeToLive) return;\n        const filteredNamespaceWithoutExpiredItems = Object.fromEntries(Object.entries(filteredNamespaceWithoutOldFormattedCacheItems).filter(([, cacheItem])=>{\n            const currentTimestamp = new Date().getTime();\n            const isExpired = cacheItem.timestamp + timeToLive < currentTimestamp;\n            return !isExpired;\n        }));\n        setNamespace(filteredNamespaceWithoutExpiredItems);\n    };\n    return {\n        get (key, defaultValue, events = {\n            miss: ()=>Promise.resolve()\n        }) {\n            return Promise.resolve().then(()=>{\n                removeOutdatedCacheItems();\n                const keyAsString = JSON.stringify(key);\n                return getNamespace()[keyAsString];\n            }).then((value)=>{\n                return Promise.all([\n                    value ? value.value : defaultValue(),\n                    value !== undefined\n                ]);\n            }).then(([value, exists])=>{\n                return Promise.all([\n                    value,\n                    exists || events.miss(value)\n                ]);\n            }).then(([value])=>value);\n        },\n        set (key, value) {\n            return Promise.resolve().then(()=>{\n                const namespace = getNamespace();\n                // eslint-disable-next-line functional/immutable-data\n                namespace[JSON.stringify(key)] = {\n                    timestamp: new Date().getTime(),\n                    value\n                };\n                getStorage().setItem(namespaceKey, JSON.stringify(namespace));\n                return value;\n            });\n        },\n        delete (key) {\n            return Promise.resolve().then(()=>{\n                const namespace = getNamespace();\n                // eslint-disable-next-line functional/immutable-data\n                delete namespace[JSON.stringify(key)];\n                getStorage().setItem(namespaceKey, JSON.stringify(namespace));\n            });\n        },\n        clear () {\n            return Promise.resolve().then(()=>{\n                getStorage().removeItem(namespaceKey);\n            });\n        }\n    };\n}\n// @todo Add logger on options to debug when caches go wrong.\nfunction createFallbackableCache(options) {\n    const caches = [\n        ...options.caches\n    ];\n    const current = caches.shift(); // eslint-disable-line functional/immutable-data\n    if (current === undefined) {\n        return createNullCache();\n    }\n    return {\n        get (key, defaultValue, events = {\n            miss: ()=>Promise.resolve()\n        }) {\n            return current.get(key, defaultValue, events).catch(()=>{\n                return createFallbackableCache({\n                    caches\n                }).get(key, defaultValue, events);\n            });\n        },\n        set (key, value) {\n            return current.set(key, value).catch(()=>{\n                return createFallbackableCache({\n                    caches\n                }).set(key, value);\n            });\n        },\n        delete (key) {\n            return current.delete(key).catch(()=>{\n                return createFallbackableCache({\n                    caches\n                }).delete(key);\n            });\n        },\n        clear () {\n            return current.clear().catch(()=>{\n                return createFallbackableCache({\n                    caches\n                }).clear();\n            });\n        }\n    };\n}\nfunction createNullCache() {\n    return {\n        get (_key, defaultValue, events = {\n            miss: ()=>Promise.resolve()\n        }) {\n            const value = defaultValue();\n            return value.then((result)=>Promise.all([\n                    result,\n                    events.miss(result)\n                ])).then(([result])=>result);\n        },\n        set (_key, value) {\n            return Promise.resolve(value);\n        },\n        delete (_key) {\n            return Promise.resolve();\n        },\n        clear () {\n            return Promise.resolve();\n        }\n    };\n}\nfunction createInMemoryCache(options = {\n    serializable: true\n}) {\n    // eslint-disable-next-line functional/no-let\n    let cache = {};\n    return {\n        get (key, defaultValue, events = {\n            miss: ()=>Promise.resolve()\n        }) {\n            const keyAsString = JSON.stringify(key);\n            if (keyAsString in cache) {\n                return Promise.resolve(options.serializable ? JSON.parse(cache[keyAsString]) : cache[keyAsString]);\n            }\n            const promise = defaultValue();\n            const miss = events && events.miss || (()=>Promise.resolve());\n            return promise.then((value)=>miss(value)).then(()=>promise);\n        },\n        set (key, value) {\n            // eslint-disable-next-line functional/immutable-data\n            cache[JSON.stringify(key)] = options.serializable ? JSON.stringify(value) : value;\n            return Promise.resolve(value);\n        },\n        delete (key) {\n            // eslint-disable-next-line functional/immutable-data\n            delete cache[JSON.stringify(key)];\n            return Promise.resolve();\n        },\n        clear () {\n            cache = {};\n            return Promise.resolve();\n        }\n    };\n}\nfunction createAuth(authMode, appId, apiKey) {\n    const credentials = {\n        \"x-algolia-api-key\": apiKey,\n        \"x-algolia-application-id\": appId\n    };\n    return {\n        headers () {\n            return authMode === AuthMode.WithinHeaders ? credentials : {};\n        },\n        queryParameters () {\n            return authMode === AuthMode.WithinQueryParameters ? credentials : {};\n        }\n    };\n}\n// eslint-disable-next-line functional/prefer-readonly-type\nfunction shuffle(array) {\n    let c = array.length - 1; // eslint-disable-line functional/no-let\n    // eslint-disable-next-line functional/no-loop-statement\n    for(c; c > 0; c--){\n        const b = Math.floor(Math.random() * (c + 1));\n        const a = array[c];\n        array[c] = array[b]; // eslint-disable-line functional/immutable-data, no-param-reassign\n        array[b] = a; // eslint-disable-line functional/immutable-data, no-param-reassign\n    }\n    return array;\n}\nfunction addMethods(base, methods) {\n    if (!methods) {\n        return base;\n    }\n    Object.keys(methods).forEach((key)=>{\n        // eslint-disable-next-line functional/immutable-data, no-param-reassign\n        base[key] = methods[key](base);\n    });\n    return base;\n}\nfunction encode(format, ...args) {\n    // eslint-disable-next-line functional/no-let\n    let i = 0;\n    return format.replace(/%s/g, ()=>encodeURIComponent(args[i++]));\n}\nconst version = \"4.22.1\";\nconst AuthMode = {\n    /**\r\n     * If auth credentials should be in query parameters.\r\n     */ WithinQueryParameters: 0,\n    /**\r\n     * If auth credentials should be in headers.\r\n     */ WithinHeaders: 1\n};\nfunction createMappedRequestOptions(requestOptions, timeout) {\n    const options = requestOptions || {};\n    const data = options.data || {};\n    Object.keys(options).forEach((key)=>{\n        if ([\n            \"timeout\",\n            \"headers\",\n            \"queryParameters\",\n            \"data\",\n            \"cacheable\"\n        ].indexOf(key) === -1) {\n            data[key] = options[key]; // eslint-disable-line functional/immutable-data\n        }\n    });\n    return {\n        data: Object.entries(data).length > 0 ? data : undefined,\n        timeout: options.timeout || timeout,\n        headers: options.headers || {},\n        queryParameters: options.queryParameters || {},\n        cacheable: options.cacheable\n    };\n}\nconst CallEnum = {\n    /**\r\n     * If the host is read only.\r\n     */ Read: 1,\n    /**\r\n     * If the host is write only.\r\n     */ Write: 2,\n    /**\r\n     * If the host is both read and write.\r\n     */ Any: 3\n};\nconst HostStatusEnum = {\n    Up: 1,\n    Down: 2,\n    Timeouted: 3\n};\n// By default, API Clients at Algolia have expiration delay\n// of 5 mins. In the JavaScript client, we have 2 mins.\nconst EXPIRATION_DELAY = 2 * 60 * 1000;\nfunction createStatefulHost(host, status = HostStatusEnum.Up) {\n    return {\n        ...host,\n        status,\n        lastUpdate: Date.now()\n    };\n}\nfunction isStatefulHostUp(host) {\n    return host.status === HostStatusEnum.Up || Date.now() - host.lastUpdate > EXPIRATION_DELAY;\n}\nfunction isStatefulHostTimeouted(host) {\n    return host.status === HostStatusEnum.Timeouted && Date.now() - host.lastUpdate <= EXPIRATION_DELAY;\n}\nfunction createStatelessHost(options) {\n    if (typeof options === \"string\") {\n        return {\n            protocol: \"https\",\n            url: options,\n            accept: CallEnum.Any\n        };\n    }\n    return {\n        protocol: options.protocol || \"https\",\n        url: options.url,\n        accept: options.accept || CallEnum.Any\n    };\n}\nconst MethodEnum = {\n    Delete: \"DELETE\",\n    Get: \"GET\",\n    Post: \"POST\",\n    Put: \"PUT\"\n};\nfunction createRetryableOptions(hostsCache, statelessHosts) {\n    return Promise.all(statelessHosts.map((statelessHost)=>{\n        return hostsCache.get(statelessHost, ()=>{\n            return Promise.resolve(createStatefulHost(statelessHost));\n        });\n    })).then((statefulHosts)=>{\n        const hostsUp = statefulHosts.filter((host)=>isStatefulHostUp(host));\n        const hostsTimeouted = statefulHosts.filter((host)=>isStatefulHostTimeouted(host));\n        /**\r\n         * Note, we put the hosts that previously timeouted on the end of the list.\r\n         */ const hostsAvailable = [\n            ...hostsUp,\n            ...hostsTimeouted\n        ];\n        const statelessHostsAvailable = hostsAvailable.length > 0 ? hostsAvailable.map((host)=>createStatelessHost(host)) : statelessHosts;\n        return {\n            getTimeout (timeoutsCount, baseTimeout) {\n                /**\r\n                 * Imagine that you have 4 hosts, if timeouts will increase\r\n                 * on the following way: 1 (timeouted) > 4 (timeouted) > 5 (200)\r\n                 *\r\n                 * Note that, the very next request, we start from the previous timeout\r\n                 *\r\n                 *  5 (timeouted) > 6 (timeouted) > 7 ...\r\n                 *\r\n                 * This strategy may need to be reviewed, but is the strategy on the our\r\n                 * current v3 version.\r\n                 */ const timeoutMultiplier = hostsTimeouted.length === 0 && timeoutsCount === 0 ? 1 : hostsTimeouted.length + 3 + timeoutsCount;\n                return timeoutMultiplier * baseTimeout;\n            },\n            statelessHosts: statelessHostsAvailable\n        };\n    });\n}\nconst isNetworkError = ({ isTimedOut, status })=>{\n    return !isTimedOut && ~~status === 0;\n};\nconst isRetryable = (response)=>{\n    const status = response.status;\n    const isTimedOut = response.isTimedOut;\n    return isTimedOut || isNetworkError(response) || ~~(status / 100) !== 2 && ~~(status / 100) !== 4;\n};\nconst isSuccess = ({ status })=>{\n    return ~~(status / 100) === 2;\n};\nconst retryDecision = (response, outcomes)=>{\n    if (isRetryable(response)) {\n        return outcomes.onRetry(response);\n    }\n    if (isSuccess(response)) {\n        return outcomes.onSuccess(response);\n    }\n    return outcomes.onFail(response);\n};\nfunction retryableRequest(transporter, statelessHosts, request, requestOptions) {\n    const stackTrace = []; // eslint-disable-line functional/prefer-readonly-type\n    /**\r\n     * First we prepare the payload that do not depend from hosts.\r\n     */ const data = serializeData(request, requestOptions);\n    const headers = serializeHeaders(transporter, requestOptions);\n    const method = request.method;\n    // On `GET`, the data is proxied to query parameters.\n    const dataQueryParameters = request.method !== MethodEnum.Get ? {} : {\n        ...request.data,\n        ...requestOptions.data\n    };\n    const queryParameters = {\n        \"x-algolia-agent\": transporter.userAgent.value,\n        ...transporter.queryParameters,\n        ...dataQueryParameters,\n        ...requestOptions.queryParameters\n    };\n    let timeoutsCount = 0; // eslint-disable-line functional/no-let\n    const retry = (hosts, getTimeout)=>{\n        /**\r\n         * We iterate on each host, until there is no host left.\r\n         */ const host = hosts.pop(); // eslint-disable-line functional/immutable-data\n        if (host === undefined) {\n            throw createRetryError(stackTraceWithoutCredentials(stackTrace));\n        }\n        const payload = {\n            data,\n            headers,\n            method,\n            url: serializeUrl(host, request.path, queryParameters),\n            connectTimeout: getTimeout(timeoutsCount, transporter.timeouts.connect),\n            responseTimeout: getTimeout(timeoutsCount, requestOptions.timeout)\n        };\n        /**\r\n         * The stackFrame is pushed to the stackTrace so we\r\n         * can have information about onRetry and onFailure\r\n         * decisions.\r\n         */ const pushToStackTrace = (response)=>{\n            const stackFrame = {\n                request: payload,\n                response,\n                host,\n                triesLeft: hosts.length\n            };\n            // eslint-disable-next-line functional/immutable-data\n            stackTrace.push(stackFrame);\n            return stackFrame;\n        };\n        const decisions = {\n            onSuccess: (response)=>deserializeSuccess(response),\n            onRetry (response) {\n                const stackFrame = pushToStackTrace(response);\n                /**\r\n                 * If response is a timeout, we increaset the number of\r\n                 * timeouts so we can increase the timeout later.\r\n                 */ if (response.isTimedOut) {\n                    timeoutsCount++;\n                }\n                return Promise.all([\n                    /**\r\n                     * Failures are individually send the logger, allowing\r\n                     * the end user to debug / store stack frames even\r\n                     * when a retry error does not happen.\r\n                     */ transporter.logger.info(\"Retryable failure\", stackFrameWithoutCredentials(stackFrame)),\n                    /**\r\n                     * We also store the state of the host in failure cases. If the host, is\r\n                     * down it will remain down for the next 2 minutes. In a timeout situation,\r\n                     * this host will be added end of the list of hosts on the next request.\r\n                     */ transporter.hostsCache.set(host, createStatefulHost(host, response.isTimedOut ? HostStatusEnum.Timeouted : HostStatusEnum.Down))\n                ]).then(()=>retry(hosts, getTimeout));\n            },\n            onFail (response) {\n                pushToStackTrace(response);\n                throw deserializeFailure(response, stackTraceWithoutCredentials(stackTrace));\n            }\n        };\n        return transporter.requester.send(payload).then((response)=>{\n            return retryDecision(response, decisions);\n        });\n    };\n    /**\r\n     * Finally, for each retryable host perform request until we got a non\r\n     * retryable response. Some notes here:\r\n     *\r\n     * 1. The reverse here is applied so we can apply a `pop` later on => more performant.\r\n     * 2. We also get from the retryable options a timeout multiplier that is tailored\r\n     * for the current context.\r\n     */ return createRetryableOptions(transporter.hostsCache, statelessHosts).then((options)=>{\n        return retry([\n            ...options.statelessHosts\n        ].reverse(), options.getTimeout);\n    });\n}\nfunction createTransporter(options) {\n    const { hostsCache, logger, requester, requestsCache, responsesCache, timeouts, userAgent, hosts, queryParameters, headers } = options;\n    const transporter = {\n        hostsCache,\n        logger,\n        requester,\n        requestsCache,\n        responsesCache,\n        timeouts,\n        userAgent,\n        headers,\n        queryParameters,\n        hosts: hosts.map((host)=>createStatelessHost(host)),\n        read (request, requestOptions) {\n            /**\r\n             * First, we compute the user request options. Now, keep in mind,\r\n             * that using request options the user is able to modified the intire\r\n             * payload of the request. Such as headers, query parameters, and others.\r\n             */ const mappedRequestOptions = createMappedRequestOptions(requestOptions, transporter.timeouts.read);\n            const createRetryableRequest = ()=>{\n                /**\r\n                 * Then, we prepare a function factory that contains the construction of\r\n                 * the retryable request. At this point, we may *not* perform the actual\r\n                 * request. But we want to have the function factory ready.\r\n                 */ return retryableRequest(transporter, transporter.hosts.filter((host)=>(host.accept & CallEnum.Read) !== 0), request, mappedRequestOptions);\n            };\n            /**\r\n             * Once we have the function factory ready, we need to determine of the\r\n             * request is \"cacheable\" - should be cached. Note that, once again,\r\n             * the user can force this option.\r\n             */ const cacheable = mappedRequestOptions.cacheable !== undefined ? mappedRequestOptions.cacheable : request.cacheable;\n            /**\r\n             * If is not \"cacheable\", we immediatly trigger the retryable request, no\r\n             * need to check cache implementations.\r\n             */ if (cacheable !== true) {\n                return createRetryableRequest();\n            }\n            /**\r\n             * If the request is \"cacheable\", we need to first compute the key to ask\r\n             * the cache implementations if this request is on progress or if the\r\n             * response already exists on the cache.\r\n             */ const key = {\n                request,\n                mappedRequestOptions,\n                transporter: {\n                    queryParameters: transporter.queryParameters,\n                    headers: transporter.headers\n                }\n            };\n            /**\r\n             * With the computed key, we first ask the responses cache\r\n             * implemention if this request was been resolved before.\r\n             */ return transporter.responsesCache.get(key, ()=>{\n                /**\r\n                 * If the request has never resolved before, we actually ask if there\r\n                 * is a current request with the same key on progress.\r\n                 */ return transporter.requestsCache.get(key, ()=>{\n                    return transporter.requestsCache/**\r\n                         * Finally, if there is no request in progress with the same key,\r\n                         * this `createRetryableRequest()` will actually trigger the\r\n                         * retryable request.\r\n                         */ .set(key, createRetryableRequest()).then((response)=>Promise.all([\n                            transporter.requestsCache.delete(key),\n                            response\n                        ]), (err)=>Promise.all([\n                            transporter.requestsCache.delete(key),\n                            Promise.reject(err)\n                        ])).then(([_, response])=>response);\n                });\n            }, {\n                /**\r\n                 * Of course, once we get this response back from the server, we\r\n                 * tell response cache to actually store the received response\r\n                 * to be used later.\r\n                 */ miss: (response)=>transporter.responsesCache.set(key, response)\n            });\n        },\n        write (request, requestOptions) {\n            /**\r\n             * On write requests, no cache mechanisms are applied, and we\r\n             * proxy the request immediately to the requester.\r\n             */ return retryableRequest(transporter, transporter.hosts.filter((host)=>(host.accept & CallEnum.Write) !== 0), request, createMappedRequestOptions(requestOptions, transporter.timeouts.write));\n        }\n    };\n    return transporter;\n}\nfunction createUserAgent(version) {\n    const userAgent = {\n        value: `Algolia for JavaScript (${version})`,\n        add (options) {\n            const addedUserAgent = `; ${options.segment}${options.version !== undefined ? ` (${options.version})` : \"\"}`;\n            if (userAgent.value.indexOf(addedUserAgent) === -1) {\n                // eslint-disable-next-line functional/immutable-data\n                userAgent.value = `${userAgent.value}${addedUserAgent}`;\n            }\n            return userAgent;\n        }\n    };\n    return userAgent;\n}\nfunction deserializeSuccess(response) {\n    // eslint-disable-next-line functional/no-try-statement\n    try {\n        return JSON.parse(response.content);\n    } catch (e) {\n        throw createDeserializationError(e.message, response);\n    }\n}\nfunction deserializeFailure({ content, status }, stackFrame) {\n    // eslint-disable-next-line functional/no-let\n    let message = content;\n    // eslint-disable-next-line functional/no-try-statement\n    try {\n        message = JSON.parse(content).message;\n    } catch (e) {\n    // ..\n    }\n    return createApiError(message, status, stackFrame);\n}\nfunction serializeUrl(host, path, queryParameters) {\n    const queryParametersAsString = serializeQueryParameters(queryParameters);\n    // eslint-disable-next-line functional/no-let\n    let url = `${host.protocol}://${host.url}/${path.charAt(0) === \"/\" ? path.substr(1) : path}`;\n    if (queryParametersAsString.length) {\n        url += `?${queryParametersAsString}`;\n    }\n    return url;\n}\nfunction serializeQueryParameters(parameters) {\n    const isObjectOrArray = (value)=>Object.prototype.toString.call(value) === \"[object Object]\" || Object.prototype.toString.call(value) === \"[object Array]\";\n    return Object.keys(parameters).map((key)=>encode(\"%s=%s\", key, isObjectOrArray(parameters[key]) ? JSON.stringify(parameters[key]) : parameters[key])).join(\"&\");\n}\nfunction serializeData(request, requestOptions) {\n    if (request.method === MethodEnum.Get || request.data === undefined && requestOptions.data === undefined) {\n        return undefined;\n    }\n    const data = Array.isArray(request.data) ? request.data : {\n        ...request.data,\n        ...requestOptions.data\n    };\n    return JSON.stringify(data);\n}\nfunction serializeHeaders(transporter, requestOptions) {\n    const headers = {\n        ...transporter.headers,\n        ...requestOptions.headers\n    };\n    const serializedHeaders = {};\n    Object.keys(headers).forEach((header)=>{\n        const value = headers[header];\n        // @ts-ignore\n        // eslint-disable-next-line functional/immutable-data\n        serializedHeaders[header.toLowerCase()] = value;\n    });\n    return serializedHeaders;\n}\nfunction stackTraceWithoutCredentials(stackTrace) {\n    return stackTrace.map((stackFrame)=>stackFrameWithoutCredentials(stackFrame));\n}\nfunction stackFrameWithoutCredentials(stackFrame) {\n    const modifiedHeaders = stackFrame.request.headers[\"x-algolia-api-key\"] ? {\n        \"x-algolia-api-key\": \"*****\"\n    } : {};\n    return {\n        ...stackFrame,\n        request: {\n            ...stackFrame.request,\n            headers: {\n                ...stackFrame.request.headers,\n                ...modifiedHeaders\n            }\n        }\n    };\n}\nfunction createApiError(message, status, transporterStackTrace) {\n    return {\n        name: \"ApiError\",\n        message,\n        status,\n        transporterStackTrace\n    };\n}\nfunction createDeserializationError(message, response) {\n    return {\n        name: \"DeserializationError\",\n        message,\n        response\n    };\n}\nfunction createRetryError(transporterStackTrace) {\n    return {\n        name: \"RetryError\",\n        message: \"Unreachable hosts - your application id may be incorrect. If the error persists, contact support@algolia.com.\",\n        transporterStackTrace\n    };\n}\nconst createSearchClient = (options)=>{\n    const appId = options.appId;\n    const auth = createAuth(options.authMode !== undefined ? options.authMode : AuthMode.WithinHeaders, appId, options.apiKey);\n    const transporter = createTransporter({\n        hosts: [\n            {\n                url: `${appId}-dsn.algolia.net`,\n                accept: CallEnum.Read\n            },\n            {\n                url: `${appId}.algolia.net`,\n                accept: CallEnum.Write\n            }\n        ].concat(shuffle([\n            {\n                url: `${appId}-1.algolianet.com`\n            },\n            {\n                url: `${appId}-2.algolianet.com`\n            },\n            {\n                url: `${appId}-3.algolianet.com`\n            }\n        ])),\n        ...options,\n        headers: {\n            ...auth.headers(),\n            ...{\n                \"content-type\": \"application/x-www-form-urlencoded\"\n            },\n            ...options.headers\n        },\n        queryParameters: {\n            ...auth.queryParameters(),\n            ...options.queryParameters\n        }\n    });\n    const base = {\n        transporter,\n        appId,\n        addAlgoliaAgent (segment, version) {\n            transporter.userAgent.add({\n                segment,\n                version\n            });\n        },\n        clearCache () {\n            return Promise.all([\n                transporter.requestsCache.clear(),\n                transporter.responsesCache.clear()\n            ]).then(()=>undefined);\n        }\n    };\n    return addMethods(base, options.methods);\n};\nconst customRequest = (base)=>{\n    return (request, requestOptions)=>{\n        if (request.method === MethodEnum.Get) {\n            return base.transporter.read(request, requestOptions);\n        }\n        return base.transporter.write(request, requestOptions);\n    };\n};\nconst initIndex = (base)=>{\n    return (indexName, options = {})=>{\n        const searchIndex = {\n            transporter: base.transporter,\n            appId: base.appId,\n            indexName\n        };\n        return addMethods(searchIndex, options.methods);\n    };\n};\nconst multipleQueries = (base)=>{\n    return (queries, requestOptions)=>{\n        const requests = queries.map((query)=>{\n            return {\n                ...query,\n                params: serializeQueryParameters(query.params || {})\n            };\n        });\n        return base.transporter.read({\n            method: MethodEnum.Post,\n            path: \"1/indexes/*/queries\",\n            data: {\n                requests\n            },\n            cacheable: true\n        }, requestOptions);\n    };\n};\nconst multipleSearchForFacetValues = (base)=>{\n    return (queries, requestOptions)=>{\n        return Promise.all(queries.map((query)=>{\n            const { facetName, facetQuery, ...params } = query.params;\n            return initIndex(base)(query.indexName, {\n                methods: {\n                    searchForFacetValues\n                }\n            }).searchForFacetValues(facetName, facetQuery, {\n                ...requestOptions,\n                ...params\n            });\n        }));\n    };\n};\nconst findAnswers = (base)=>{\n    return (query, queryLanguages, requestOptions)=>{\n        return base.transporter.read({\n            method: MethodEnum.Post,\n            path: encode(\"1/answers/%s/prediction\", base.indexName),\n            data: {\n                query,\n                queryLanguages\n            },\n            cacheable: true\n        }, requestOptions);\n    };\n};\nconst search = (base)=>{\n    return (query, requestOptions)=>{\n        return base.transporter.read({\n            method: MethodEnum.Post,\n            path: encode(\"1/indexes/%s/query\", base.indexName),\n            data: {\n                query\n            },\n            cacheable: true\n        }, requestOptions);\n    };\n};\nconst searchForFacetValues = (base)=>{\n    return (facetName, facetQuery, requestOptions)=>{\n        return base.transporter.read({\n            method: MethodEnum.Post,\n            path: encode(\"1/indexes/%s/facets/%s/query\", base.indexName, facetName),\n            data: {\n                facetQuery\n            },\n            cacheable: true\n        }, requestOptions);\n    };\n};\nconst LogLevelEnum = {\n    Debug: 1,\n    Info: 2,\n    Error: 3\n};\n/* eslint no-console: 0 */ function createConsoleLogger(logLevel) {\n    return {\n        debug (message, args) {\n            if (LogLevelEnum.Debug >= logLevel) {\n                console.debug(message, args);\n            }\n            return Promise.resolve();\n        },\n        info (message, args) {\n            if (LogLevelEnum.Info >= logLevel) {\n                console.info(message, args);\n            }\n            return Promise.resolve();\n        },\n        error (message, args) {\n            console.error(message, args);\n            return Promise.resolve();\n        }\n    };\n}\nfunction createBrowserXhrRequester() {\n    return {\n        send (request) {\n            return new Promise((resolve)=>{\n                const baseRequester = new XMLHttpRequest();\n                baseRequester.open(request.method, request.url, true);\n                Object.keys(request.headers).forEach((key)=>baseRequester.setRequestHeader(key, request.headers[key]));\n                const createTimeout = (timeout, content)=>{\n                    return setTimeout(()=>{\n                        baseRequester.abort();\n                        resolve({\n                            status: 0,\n                            content,\n                            isTimedOut: true\n                        });\n                    }, timeout * 1000);\n                };\n                const connectTimeout = createTimeout(request.connectTimeout, \"Connection timeout\");\n                // eslint-disable-next-line functional/no-let\n                let responseTimeout;\n                // eslint-disable-next-line functional/immutable-data\n                baseRequester.onreadystatechange = ()=>{\n                    if (baseRequester.readyState > baseRequester.OPENED && responseTimeout === undefined) {\n                        clearTimeout(connectTimeout);\n                        responseTimeout = createTimeout(request.responseTimeout, \"Socket timeout\");\n                    }\n                };\n                // eslint-disable-next-line functional/immutable-data\n                baseRequester.onerror = ()=>{\n                    // istanbul ignore next\n                    if (baseRequester.status === 0) {\n                        clearTimeout(connectTimeout);\n                        clearTimeout(responseTimeout);\n                        resolve({\n                            content: baseRequester.responseText || \"Network request failed\",\n                            status: baseRequester.status,\n                            isTimedOut: false\n                        });\n                    }\n                };\n                //  eslint-disable-next-line functional/immutable-data\n                baseRequester.onload = ()=>{\n                    clearTimeout(connectTimeout);\n                    clearTimeout(responseTimeout);\n                    resolve({\n                        content: baseRequester.responseText,\n                        status: baseRequester.status,\n                        isTimedOut: false\n                    });\n                };\n                baseRequester.send(request.data);\n            });\n        }\n    };\n}\nfunction algoliasearch(appId, apiKey, options) {\n    const commonOptions = {\n        appId,\n        apiKey,\n        timeouts: {\n            connect: 1,\n            read: 2,\n            write: 30\n        },\n        requester: createBrowserXhrRequester(),\n        logger: createConsoleLogger(LogLevelEnum.Error),\n        responsesCache: createInMemoryCache(),\n        requestsCache: createInMemoryCache({\n            serializable: false\n        }),\n        hostsCache: createFallbackableCache({\n            caches: [\n                createBrowserLocalStorageCache({\n                    key: `${version}-${appId}`\n                }),\n                createInMemoryCache()\n            ]\n        }),\n        userAgent: createUserAgent(version).add({\n            segment: \"Browser\",\n            version: \"lite\"\n        }),\n        authMode: AuthMode.WithinQueryParameters\n    };\n    return createSearchClient({\n        ...commonOptions,\n        ...options,\n        methods: {\n            search: multipleQueries,\n            searchForFacetValues: multipleSearchForFacetValues,\n            multipleQueries,\n            multipleSearchForFacetValues,\n            customRequest,\n            initIndex: (base)=>(indexName)=>{\n                    return initIndex(base)(indexName, {\n                        methods: {\n                            search,\n                            searchForFacetValues,\n                            findAnswers\n                        }\n                    });\n                }\n        }\n    });\n}\n// eslint-disable-next-line functional/immutable-data\nalgoliasearch.version = version;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (algoliasearch);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vYWxnb2xpYXNlYXJjaEA0LjIyLjEvbm9kZV9tb2R1bGVzL2FsZ29saWFzZWFyY2gvZGlzdC9hbGdvbGlhc2VhcmNoLWxpdGUuZXNtLmJyb3dzZXIuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLFNBQVNBLCtCQUErQkMsT0FBTztJQUMzQyxNQUFNQyxlQUFlLENBQUMsd0JBQXdCLEVBQUVELFFBQVFFLEdBQUcsQ0FBQyxDQUFDO0lBQzdELDZDQUE2QztJQUM3QyxJQUFJQztJQUNKLE1BQU1DLGFBQWE7UUFDZixJQUFJRCxZQUFZRSxXQUFXO1lBQ3ZCRixVQUFVSCxRQUFRTSxZQUFZLElBQUlDLE9BQU9ELFlBQVk7UUFDekQ7UUFDQSxPQUFPSDtJQUNYO0lBQ0EsTUFBTUssZUFBZTtRQUNqQixPQUFPQyxLQUFLQyxLQUFLLENBQUNOLGFBQWFPLE9BQU8sQ0FBQ1YsaUJBQWlCO0lBQzVEO0lBQ0EsTUFBTVcsZUFBZSxDQUFDQztRQUNsQlQsYUFBYVUsT0FBTyxDQUFDYixjQUFjUSxLQUFLTSxTQUFTLENBQUNGO0lBQ3REO0lBQ0EsTUFBTUcsMkJBQTJCO1FBQzdCLE1BQU1DLGFBQWFqQixRQUFRaUIsVUFBVSxHQUFHakIsUUFBUWlCLFVBQVUsR0FBRyxPQUFPO1FBQ3BFLE1BQU1KLFlBQVlMO1FBQ2xCLE1BQU1VLGlEQUFpREMsT0FBT0MsV0FBVyxDQUFDRCxPQUFPRSxPQUFPLENBQUNSLFdBQVdTLE1BQU0sQ0FBQyxDQUFDLEdBQUdDLFVBQVU7WUFDckgsT0FBT0EsVUFBVUMsU0FBUyxLQUFLbkI7UUFDbkM7UUFDQU8sYUFBYU07UUFDYixJQUFJLENBQUNELFlBQ0Q7UUFDSixNQUFNUSx1Q0FBdUNOLE9BQU9DLFdBQVcsQ0FBQ0QsT0FBT0UsT0FBTyxDQUFDSCxnREFBZ0RJLE1BQU0sQ0FBQyxDQUFDLEdBQUdDLFVBQVU7WUFDaEosTUFBTUcsbUJBQW1CLElBQUlDLE9BQU9DLE9BQU87WUFDM0MsTUFBTUMsWUFBWU4s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ckQyQixjQUFjNUssT0FBTyxHQUFHQTtBQUV4QixpRUFBZTRLLGFBQWFBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90YWlsd2luZC1uZXh0anMtc3RhcnRlci1ibG9nLy4vbm9kZV9tb2R1bGVzLy5wbnBtL2FsZ29saWFzZWFyY2hANC4yMi4xL25vZGVfbW9kdWxlcy9hbGdvbGlhc2VhcmNoL2Rpc3QvYWxnb2xpYXNlYXJjaC1saXRlLmVzbS5icm93c2VyLmpzP2FiM2YiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gY3JlYXRlQnJvd3NlckxvY2FsU3RvcmFnZUNhY2hlKG9wdGlvbnMpIHtcclxuICAgIGNvbnN0IG5hbWVzcGFjZUtleSA9IGBhbGdvbGlhc2VhcmNoLWNsaWVudC1qcy0ke29wdGlvbnMua2V5fWA7XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuY3Rpb25hbC9uby1sZXRcclxuICAgIGxldCBzdG9yYWdlO1xyXG4gICAgY29uc3QgZ2V0U3RvcmFnZSA9ICgpID0+IHtcclxuICAgICAgICBpZiAoc3RvcmFnZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHN0b3JhZ2UgPSBvcHRpb25zLmxvY2FsU3RvcmFnZSB8fCB3aW5kb3cubG9jYWxTdG9yYWdlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc3RvcmFnZTtcclxuICAgIH07XHJcbiAgICBjb25zdCBnZXROYW1lc3BhY2UgPSAoKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoZ2V0U3RvcmFnZSgpLmdldEl0ZW0obmFtZXNwYWNlS2V5KSB8fCAne30nKTtcclxuICAgIH07XHJcbiAgICBjb25zdCBzZXROYW1lc3BhY2UgPSAobmFtZXNwYWNlKSA9PiB7XHJcbiAgICAgICAgZ2V0U3RvcmFnZSgpLnNldEl0ZW0obmFtZXNwYWNlS2V5LCBKU09OLnN0cmluZ2lmeShuYW1lc3BhY2UpKTtcclxuICAgIH07XHJcbiAgICBjb25zdCByZW1vdmVPdXRkYXRlZENhY2hlSXRlbXMgPSAoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgdGltZVRvTGl2ZSA9IG9wdGlvbnMudGltZVRvTGl2ZSA/IG9wdGlvbnMudGltZVRvTGl2ZSAqIDEwMDAgOiBudWxsO1xyXG4gICAgICAgIGNvbnN0IG5hbWVzcGFjZSA9IGdldE5hbWVzcGFjZSgpO1xyXG4gICAgICAgIGNvbnN0IGZpbHRlcmVkTmFtZXNwYWNlV2l0aG91dE9sZEZvcm1hdHRlZENhY2hlSXRlbXMgPSBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMobmFtZXNwYWNlKS5maWx0ZXIoKFssIGNhY2hlSXRlbV0pID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlSXRlbS50aW1lc3RhbXAgIT09IHVuZGVmaW5lZDtcclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgc2V0TmFtZXNwYWNlKGZpbHRlcmVkTmFtZXNwYWNlV2l0aG91dE9sZEZvcm1hdHRlZENhY2hlSXRlbXMpO1xyXG4gICAgICAgIGlmICghdGltZVRvTGl2ZSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIGNvbnN0IGZpbHRlcmVkTmFtZXNwYWNlV2l0aG91dEV4cGlyZWRJdGVtcyA9IE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhmaWx0ZXJlZE5hbWVzcGFjZVdpdGhvdXRPbGRGb3JtYXR0ZWRDYWNoZUl0ZW1zKS5maWx0ZXIoKFssIGNhY2hlSXRlbV0pID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY3VycmVudFRpbWVzdGFtcCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG4gICAgICAgICAgICBjb25zdCBpc0V4cGlyZWQgPSBjYWNoZUl0ZW0udGltZXN0YW1wICsgdGltZVRvTGl2ZSA8IGN1cnJlbnRUaW1lc3RhbXA7XHJcbiAgICAgICAgICAgIHJldHVybiAhaXNFeHBpcmVkO1xyXG4gICAgICAgIH0pKTtcclxuICAgICAgICBzZXROYW1lc3BhY2UoZmlsdGVyZWROYW1lc3BhY2VXaXRob3V0RXhwaXJlZEl0ZW1zKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGdldChrZXksIGRlZmF1bHRWYWx1ZSwgZXZlbnRzID0ge1xyXG4gICAgICAgICAgICBtaXNzOiAoKSA9PiBQcm9taXNlLnJlc29sdmUoKSxcclxuICAgICAgICB9KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmVtb3ZlT3V0ZGF0ZWRDYWNoZUl0ZW1zKCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlBc1N0cmluZyA9IEpTT04uc3RyaW5naWZ5KGtleSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0TmFtZXNwYWNlKClba2V5QXNTdHJpbmddO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLnRoZW4odmFsdWUgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFt2YWx1ZSA/IHZhbHVlLnZhbHVlIDogZGVmYXVsdFZhbHVlKCksIHZhbHVlICE9PSB1bmRlZmluZWRdKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC50aGVuKChbdmFsdWUsIGV4aXN0c10pID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbdmFsdWUsIGV4aXN0cyB8fCBldmVudHMubWlzcyh2YWx1ZSldKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC50aGVuKChbdmFsdWVdKSA9PiB2YWx1ZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuYW1lc3BhY2UgPSBnZXROYW1lc3BhY2UoKTtcclxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jdGlvbmFsL2ltbXV0YWJsZS1kYXRhXHJcbiAgICAgICAgICAgICAgICBuYW1lc3BhY2VbSlNPTi5zdHJpbmdpZnkoa2V5KV0gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLmdldFRpbWUoKSxcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBnZXRTdG9yYWdlKCkuc2V0SXRlbShuYW1lc3BhY2VLZXksIEpTT04uc3RyaW5naWZ5KG5hbWVzcGFjZSkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRlbGV0ZShrZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmFtZXNwYWNlID0gZ2V0TmFtZXNwYWNlKCk7XHJcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuY3Rpb25hbC9pbW11dGFibGUtZGF0YVxyXG4gICAgICAgICAgICAgICAgZGVsZXRlIG5hbWVzcGFjZVtKU09OLnN0cmluZ2lmeShrZXkpXTtcclxuICAgICAgICAgICAgICAgIGdldFN0b3JhZ2UoKS5zZXRJdGVtKG5hbWVzcGFjZUtleSwgSlNPTi5zdHJpbmdpZnkobmFtZXNwYWNlKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY2xlYXIoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGdldFN0b3JhZ2UoKS5yZW1vdmVJdGVtKG5hbWVzcGFjZUtleSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG59XG5cbi8vIEB0b2RvIEFkZCBsb2dnZXIgb24gb3B0aW9ucyB0byBkZWJ1ZyB3aGVuIGNhY2hlcyBnbyB3cm9uZy5cclxuZnVuY3Rpb24gY3JlYXRlRmFsbGJhY2thYmxlQ2FjaGUob3B0aW9ucykge1xyXG4gICAgY29uc3QgY2FjaGVzID0gWy4uLm9wdGlvbnMuY2FjaGVzXTtcclxuICAgIGNvbnN0IGN1cnJlbnQgPSBjYWNoZXMuc2hpZnQoKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBmdW5jdGlvbmFsL2ltbXV0YWJsZS1kYXRhXHJcbiAgICBpZiAoY3VycmVudCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZU51bGxDYWNoZSgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBnZXQoa2V5LCBkZWZhdWx0VmFsdWUsIGV2ZW50cyA9IHtcclxuICAgICAgICAgICAgbWlzczogKCkgPT4gUHJvbWlzZS5yZXNvbHZlKCksXHJcbiAgICAgICAgfSkge1xyXG4gICAgICAgICAgICByZXR1cm4gY3VycmVudC5nZXQoa2V5LCBkZWZhdWx0VmFsdWUsIGV2ZW50cykuY2F0Y2goKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUZhbGxiYWNrYWJsZUNhY2hlKHsgY2FjaGVzIH0pLmdldChrZXksIGRlZmF1bHRWYWx1ZSwgZXZlbnRzKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gY3VycmVudC5zZXQoa2V5LCB2YWx1ZSkuY2F0Y2goKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUZhbGxiYWNrYWJsZUNhY2hlKHsgY2FjaGVzIH0pLnNldChrZXksIHZhbHVlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBkZWxldGUoa2V5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50LmRlbGV0ZShrZXkpLmNhdGNoKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVGYWxsYmFja2FibGVDYWNoZSh7IGNhY2hlcyB9KS5kZWxldGUoa2V5KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjbGVhcigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnQuY2xlYXIoKS5jYXRjaCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlRmFsbGJhY2thYmxlQ2FjaGUoeyBjYWNoZXMgfSkuY2xlYXIoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbn1cblxuZnVuY3Rpb24gY3JlYXRlTnVsbENhY2hlKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBnZXQoX2tleSwgZGVmYXVsdFZhbHVlLCBldmVudHMgPSB7XHJcbiAgICAgICAgICAgIG1pc3M6ICgpID0+IFByb21pc2UucmVzb2x2ZSgpLFxyXG4gICAgICAgIH0pIHtcclxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBkZWZhdWx0VmFsdWUoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlXHJcbiAgICAgICAgICAgICAgICAudGhlbihyZXN1bHQgPT4gUHJvbWlzZS5hbGwoW3Jlc3VsdCwgZXZlbnRzLm1pc3MocmVzdWx0KV0pKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oKFtyZXN1bHRdKSA9PiByZXN1bHQpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0KF9rZXksIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGVsZXRlKF9rZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY2xlYXIoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxuXG5mdW5jdGlvbiBjcmVhdGVJbk1lbW9yeUNhY2hlKG9wdGlvbnMgPSB7IHNlcmlhbGl6YWJsZTogdHJ1ZSB9KSB7XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuY3Rpb25hbC9uby1sZXRcclxuICAgIGxldCBjYWNoZSA9IHt9O1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBnZXQoa2V5LCBkZWZhdWx0VmFsdWUsIGV2ZW50cyA9IHtcclxuICAgICAgICAgICAgbWlzczogKCkgPT4gUHJvbWlzZS5yZXNvbHZlKCksXHJcbiAgICAgICAgfSkge1xyXG4gICAgICAgICAgICBjb25zdCBrZXlBc1N0cmluZyA9IEpTT04uc3RyaW5naWZ5KGtleSk7XHJcbiAgICAgICAgICAgIGlmIChrZXlBc1N0cmluZyBpbiBjYWNoZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShvcHRpb25zLnNlcmlhbGl6YWJsZSA/IEpTT04ucGFyc2UoY2FjaGVba2V5QXNTdHJpbmddKSA6IGNhY2hlW2tleUFzU3RyaW5nXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgcHJvbWlzZSA9IGRlZmF1bHRWYWx1ZSgpO1xyXG4gICAgICAgICAgICBjb25zdCBtaXNzID0gKGV2ZW50cyAmJiBldmVudHMubWlzcykgfHwgKCgpID0+IFByb21pc2UucmVzb2x2ZSgpKTtcclxuICAgICAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbigodmFsdWUpID0+IG1pc3ModmFsdWUpKS50aGVuKCgpID0+IHByb21pc2UpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0KGtleSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmN0aW9uYWwvaW1tdXRhYmxlLWRhdGFcclxuICAgICAgICAgICAgY2FjaGVbSlNPTi5zdHJpbmdpZnkoa2V5KV0gPSBvcHRpb25zLnNlcmlhbGl6YWJsZSA/IEpTT04uc3RyaW5naWZ5KHZhbHVlKSA6IHZhbHVlO1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRlbGV0ZShrZXkpIHtcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmN0aW9uYWwvaW1tdXRhYmxlLWRhdGFcclxuICAgICAgICAgICAgZGVsZXRlIGNhY2hlW0pTT04uc3RyaW5naWZ5KGtleSldO1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjbGVhcigpIHtcclxuICAgICAgICAgICAgY2FjaGUgPSB7fTtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUF1dGgoYXV0aE1vZGUsIGFwcElkLCBhcGlLZXkpIHtcclxuICAgIGNvbnN0IGNyZWRlbnRpYWxzID0ge1xyXG4gICAgICAgICd4LWFsZ29saWEtYXBpLWtleSc6IGFwaUtleSxcclxuICAgICAgICAneC1hbGdvbGlhLWFwcGxpY2F0aW9uLWlkJzogYXBwSWQsXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBoZWFkZXJzKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYXV0aE1vZGUgPT09IEF1dGhNb2RlLldpdGhpbkhlYWRlcnMgPyBjcmVkZW50aWFscyA6IHt9O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcXVlcnlQYXJhbWV0ZXJzKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYXV0aE1vZGUgPT09IEF1dGhNb2RlLldpdGhpblF1ZXJ5UGFyYW1ldGVycyA/IGNyZWRlbnRpYWxzIDoge307XHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmN0aW9uYWwvcHJlZmVyLXJlYWRvbmx5LXR5cGVcclxuZnVuY3Rpb24gc2h1ZmZsZShhcnJheSkge1xyXG4gICAgbGV0IGMgPSBhcnJheS5sZW5ndGggLSAxOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGZ1bmN0aW9uYWwvbm8tbGV0XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuY3Rpb25hbC9uby1sb29wLXN0YXRlbWVudFxyXG4gICAgZm9yIChjOyBjID4gMDsgYy0tKSB7XHJcbiAgICAgICAgY29uc3QgYiA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChjICsgMSkpO1xyXG4gICAgICAgIGNvbnN0IGEgPSBhcnJheVtjXTtcclxuICAgICAgICBhcnJheVtjXSA9IGFycmF5W2JdOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGZ1bmN0aW9uYWwvaW1tdXRhYmxlLWRhdGEsIG5vLXBhcmFtLXJlYXNzaWduXHJcbiAgICAgICAgYXJyYXlbYl0gPSBhOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGZ1bmN0aW9uYWwvaW1tdXRhYmxlLWRhdGEsIG5vLXBhcmFtLXJlYXNzaWduXHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXJyYXk7XHJcbn1cclxuZnVuY3Rpb24gYWRkTWV0aG9kcyhiYXNlLCBtZXRob2RzKSB7XHJcbiAgICBpZiAoIW1ldGhvZHMpIHtcclxuICAgICAgICByZXR1cm4gYmFzZTtcclxuICAgIH1cclxuICAgIE9iamVjdC5rZXlzKG1ldGhvZHMpLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuY3Rpb25hbC9pbW11dGFibGUtZGF0YSwgbm8tcGFyYW0tcmVhc3NpZ25cclxuICAgICAgICBiYXNlW2tleV0gPSBtZXRob2RzW2tleV0oYmFzZSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBiYXNlO1xyXG59XHJcbmZ1bmN0aW9uIGVuY29kZShmb3JtYXQsIC4uLmFyZ3MpIHtcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jdGlvbmFsL25vLWxldFxyXG4gICAgbGV0IGkgPSAwO1xyXG4gICAgcmV0dXJuIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCAoKSA9PiBlbmNvZGVVUklDb21wb25lbnQoYXJnc1tpKytdKSk7XHJcbn1cblxuY29uc3QgdmVyc2lvbiA9ICc0LjIyLjEnO1xuXG5jb25zdCBBdXRoTW9kZSA9IHtcclxuICAgIC8qKlxyXG4gICAgICogSWYgYXV0aCBjcmVkZW50aWFscyBzaG91bGQgYmUgaW4gcXVlcnkgcGFyYW1ldGVycy5cclxuICAgICAqL1xyXG4gICAgV2l0aGluUXVlcnlQYXJhbWV0ZXJzOiAwLFxyXG4gICAgLyoqXHJcbiAgICAgKiBJZiBhdXRoIGNyZWRlbnRpYWxzIHNob3VsZCBiZSBpbiBoZWFkZXJzLlxyXG4gICAgICovXHJcbiAgICBXaXRoaW5IZWFkZXJzOiAxLFxyXG59O1xuXG5mdW5jdGlvbiBjcmVhdGVNYXBwZWRSZXF1ZXN0T3B0aW9ucyhyZXF1ZXN0T3B0aW9ucywgdGltZW91dCkge1xyXG4gICAgY29uc3Qgb3B0aW9ucyA9IHJlcXVlc3RPcHRpb25zIHx8IHt9O1xyXG4gICAgY29uc3QgZGF0YSA9IG9wdGlvbnMuZGF0YSB8fCB7fTtcclxuICAgIE9iamVjdC5rZXlzKG9wdGlvbnMpLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgICBpZiAoWyd0aW1lb3V0JywgJ2hlYWRlcnMnLCAncXVlcnlQYXJhbWV0ZXJzJywgJ2RhdGEnLCAnY2FjaGVhYmxlJ10uaW5kZXhPZihrZXkpID09PSAtMSkge1xyXG4gICAgICAgICAgICBkYXRhW2tleV0gPSBvcHRpb25zW2tleV07IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZnVuY3Rpb25hbC9pbW11dGFibGUtZGF0YVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBkYXRhOiBPYmplY3QuZW50cmllcyhkYXRhKS5sZW5ndGggPiAwID8gZGF0YSA6IHVuZGVmaW5lZCxcclxuICAgICAgICB0aW1lb3V0OiBvcHRpb25zLnRpbWVvdXQgfHwgdGltZW91dCxcclxuICAgICAgICBoZWFkZXJzOiBvcHRpb25zLmhlYWRlcnMgfHwge30sXHJcbiAgICAgICAgcXVlcnlQYXJhbWV0ZXJzOiBvcHRpb25zLnF1ZXJ5UGFyYW1ldGVycyB8fCB7fSxcclxuICAgICAgICBjYWNoZWFibGU6IG9wdGlvbnMuY2FjaGVhYmxlLFxyXG4gICAgfTtcclxufVxuXG5jb25zdCBDYWxsRW51bSA9IHtcclxuICAgIC8qKlxyXG4gICAgICogSWYgdGhlIGhvc3QgaXMgcmVhZCBvbmx5LlxyXG4gICAgICovXHJcbiAgICBSZWFkOiAxLFxyXG4gICAgLyoqXHJcbiAgICAgKiBJZiB0aGUgaG9zdCBpcyB3cml0ZSBvbmx5LlxyXG4gICAgICovXHJcbiAgICBXcml0ZTogMixcclxuICAgIC8qKlxyXG4gICAgICogSWYgdGhlIGhvc3QgaXMgYm90aCByZWFkIGFuZCB3cml0ZS5cclxuICAgICAqL1xyXG4gICAgQW55OiAzLFxyXG59O1xuXG5jb25zdCBIb3N0U3RhdHVzRW51bSA9IHtcclxuICAgIFVwOiAxLFxyXG4gICAgRG93bjogMixcclxuICAgIFRpbWVvdXRlZDogMyxcclxufTtcblxuLy8gQnkgZGVmYXVsdCwgQVBJIENsaWVudHMgYXQgQWxnb2xpYSBoYXZlIGV4cGlyYXRpb24gZGVsYXlcclxuLy8gb2YgNSBtaW5zLiBJbiB0aGUgSmF2YVNjcmlwdCBjbGllbnQsIHdlIGhhdmUgMiBtaW5zLlxyXG5jb25zdCBFWFBJUkFUSU9OX0RFTEFZID0gMiAqIDYwICogMTAwMDtcclxuZnVuY3Rpb24gY3JlYXRlU3RhdGVmdWxIb3N0KGhvc3QsIHN0YXR1cyA9IEhvc3RTdGF0dXNFbnVtLlVwKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIC4uLmhvc3QsXHJcbiAgICAgICAgc3RhdHVzLFxyXG4gICAgICAgIGxhc3RVcGRhdGU6IERhdGUubm93KCksXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGlzU3RhdGVmdWxIb3N0VXAoaG9zdCkge1xyXG4gICAgcmV0dXJuIGhvc3Quc3RhdHVzID09PSBIb3N0U3RhdHVzRW51bS5VcCB8fCBEYXRlLm5vdygpIC0gaG9zdC5sYXN0VXBkYXRlID4gRVhQSVJBVElPTl9ERUxBWTtcclxufVxyXG5mdW5jdGlvbiBpc1N0YXRlZnVsSG9zdFRpbWVvdXRlZChob3N0KSB7XHJcbiAgICByZXR1cm4gKGhvc3Quc3RhdHVzID09PSBIb3N0U3RhdHVzRW51bS5UaW1lb3V0ZWQgJiYgRGF0ZS5ub3coKSAtIGhvc3QubGFzdFVwZGF0ZSA8PSBFWFBJUkFUSU9OX0RFTEFZKTtcclxufVxuXG5mdW5jdGlvbiBjcmVhdGVTdGF0ZWxlc3NIb3N0KG9wdGlvbnMpIHtcclxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBwcm90b2NvbDogJ2h0dHBzJyxcclxuICAgICAgICAgICAgdXJsOiBvcHRpb25zLFxyXG4gICAgICAgICAgICBhY2NlcHQ6IENhbGxFbnVtLkFueSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBwcm90b2NvbDogb3B0aW9ucy5wcm90b2NvbCB8fCAnaHR0cHMnLFxyXG4gICAgICAgIHVybDogb3B0aW9ucy51cmwsXHJcbiAgICAgICAgYWNjZXB0OiBvcHRpb25zLmFjY2VwdCB8fCBDYWxsRW51bS5BbnksXHJcbiAgICB9O1xyXG59XG5cbmNvbnN0IE1ldGhvZEVudW0gPSB7XHJcbiAgICBEZWxldGU6ICdERUxFVEUnLFxyXG4gICAgR2V0OiAnR0VUJyxcclxuICAgIFBvc3Q6ICdQT1NUJyxcclxuICAgIFB1dDogJ1BVVCcsXHJcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZVJldHJ5YWJsZU9wdGlvbnMoaG9zdHNDYWNoZSwgc3RhdGVsZXNzSG9zdHMpIHtcclxuICAgIHJldHVybiBQcm9taXNlLmFsbChzdGF0ZWxlc3NIb3N0cy5tYXAoc3RhdGVsZXNzSG9zdCA9PiB7XHJcbiAgICAgICAgcmV0dXJuIGhvc3RzQ2FjaGUuZ2V0KHN0YXRlbGVzc0hvc3QsICgpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjcmVhdGVTdGF0ZWZ1bEhvc3Qoc3RhdGVsZXNzSG9zdCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSkpLnRoZW4oc3RhdGVmdWxIb3N0cyA9PiB7XHJcbiAgICAgICAgY29uc3QgaG9zdHNVcCA9IHN0YXRlZnVsSG9zdHMuZmlsdGVyKGhvc3QgPT4gaXNTdGF0ZWZ1bEhvc3RVcChob3N0KSk7XHJcbiAgICAgICAgY29uc3QgaG9zdHNUaW1lb3V0ZWQgPSBzdGF0ZWZ1bEhvc3RzLmZpbHRlcihob3N0ID0+IGlzU3RhdGVmdWxIb3N0VGltZW91dGVkKGhvc3QpKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBOb3RlLCB3ZSBwdXQgdGhlIGhvc3RzIHRoYXQgcHJldmlvdXNseSB0aW1lb3V0ZWQgb24gdGhlIGVuZCBvZiB0aGUgbGlzdC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBjb25zdCBob3N0c0F2YWlsYWJsZSA9IFsuLi5ob3N0c1VwLCAuLi5ob3N0c1RpbWVvdXRlZF07XHJcbiAgICAgICAgY29uc3Qgc3RhdGVsZXNzSG9zdHNBdmFpbGFibGUgPSBob3N0c0F2YWlsYWJsZS5sZW5ndGggPiAwXHJcbiAgICAgICAgICAgID8gaG9zdHNBdmFpbGFibGUubWFwKGhvc3QgPT4gY3JlYXRlU3RhdGVsZXNzSG9zdChob3N0KSlcclxuICAgICAgICAgICAgOiBzdGF0ZWxlc3NIb3N0cztcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBnZXRUaW1lb3V0KHRpbWVvdXRzQ291bnQsIGJhc2VUaW1lb3V0KSB7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEltYWdpbmUgdGhhdCB5b3UgaGF2ZSA0IGhvc3RzLCBpZiB0aW1lb3V0cyB3aWxsIGluY3JlYXNlXHJcbiAgICAgICAgICAgICAgICAgKiBvbiB0aGUgZm9sbG93aW5nIHdheTogMSAodGltZW91dGVkKSA+IDQgKHRpbWVvdXRlZCkgPiA1ICgyMDApXHJcbiAgICAgICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgICAgICogTm90ZSB0aGF0LCB0aGUgdmVyeSBuZXh0IHJlcXVlc3QsIHdlIHN0YXJ0IGZyb20gdGhlIHByZXZpb3VzIHRpbWVvdXRcclxuICAgICAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAgICAgKiAgNSAodGltZW91dGVkKSA+IDYgKHRpbWVvdXRlZCkgPiA3IC4uLlxyXG4gICAgICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICAgICAqIFRoaXMgc3RyYXRlZ3kgbWF5IG5lZWQgdG8gYmUgcmV2aWV3ZWQsIGJ1dCBpcyB0aGUgc3RyYXRlZ3kgb24gdGhlIG91clxyXG4gICAgICAgICAgICAgICAgICogY3VycmVudCB2MyB2ZXJzaW9uLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBjb25zdCB0aW1lb3V0TXVsdGlwbGllciA9IGhvc3RzVGltZW91dGVkLmxlbmd0aCA9PT0gMCAmJiB0aW1lb3V0c0NvdW50ID09PSAwXHJcbiAgICAgICAgICAgICAgICAgICAgPyAxXHJcbiAgICAgICAgICAgICAgICAgICAgOiBob3N0c1RpbWVvdXRlZC5sZW5ndGggKyAzICsgdGltZW91dHNDb3VudDtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aW1lb3V0TXVsdGlwbGllciAqIGJhc2VUaW1lb3V0O1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzdGF0ZWxlc3NIb3N0czogc3RhdGVsZXNzSG9zdHNBdmFpbGFibGUsXHJcbiAgICAgICAgfTtcclxuICAgIH0pO1xyXG59XG5cbmNvbnN0IGlzTmV0d29ya0Vycm9yID0gKHsgaXNUaW1lZE91dCwgc3RhdHVzIH0pID0+IHtcclxuICAgIHJldHVybiAhaXNUaW1lZE91dCAmJiB+fnN0YXR1cyA9PT0gMDtcclxufTtcclxuY29uc3QgaXNSZXRyeWFibGUgPSAocmVzcG9uc2UpID0+IHtcclxuICAgIGNvbnN0IHN0YXR1cyA9IHJlc3BvbnNlLnN0YXR1cztcclxuICAgIGNvbnN0IGlzVGltZWRPdXQgPSByZXNwb25zZS5pc1RpbWVkT3V0O1xyXG4gICAgcmV0dXJuIChpc1RpbWVkT3V0IHx8IGlzTmV0d29ya0Vycm9yKHJlc3BvbnNlKSB8fCAofn4oc3RhdHVzIC8gMTAwKSAhPT0gMiAmJiB+fihzdGF0dXMgLyAxMDApICE9PSA0KSk7XHJcbn07XHJcbmNvbnN0IGlzU3VjY2VzcyA9ICh7IHN0YXR1cyB9KSA9PiB7XHJcbiAgICByZXR1cm4gfn4oc3RhdHVzIC8gMTAwKSA9PT0gMjtcclxufTtcclxuY29uc3QgcmV0cnlEZWNpc2lvbiA9IChyZXNwb25zZSwgb3V0Y29tZXMpID0+IHtcclxuICAgIGlmIChpc1JldHJ5YWJsZShyZXNwb25zZSkpIHtcclxuICAgICAgICByZXR1cm4gb3V0Y29tZXMub25SZXRyeShyZXNwb25zZSk7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNTdWNjZXNzKHJlc3BvbnNlKSkge1xyXG4gICAgICAgIHJldHVybiBvdXRjb21lcy5vblN1Y2Nlc3MocmVzcG9uc2UpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG91dGNvbWVzLm9uRmFpbChyZXNwb25zZSk7XHJcbn07XG5cbmZ1bmN0aW9uIHJldHJ5YWJsZVJlcXVlc3QodHJhbnNwb3J0ZXIsIHN0YXRlbGVzc0hvc3RzLCByZXF1ZXN0LCByZXF1ZXN0T3B0aW9ucykge1xyXG4gICAgY29uc3Qgc3RhY2tUcmFjZSA9IFtdOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGZ1bmN0aW9uYWwvcHJlZmVyLXJlYWRvbmx5LXR5cGVcclxuICAgIC8qKlxyXG4gICAgICogRmlyc3Qgd2UgcHJlcGFyZSB0aGUgcGF5bG9hZCB0aGF0IGRvIG5vdCBkZXBlbmQgZnJvbSBob3N0cy5cclxuICAgICAqL1xyXG4gICAgY29uc3QgZGF0YSA9IHNlcmlhbGl6ZURhdGEocmVxdWVzdCwgcmVxdWVzdE9wdGlvbnMpO1xyXG4gICAgY29uc3QgaGVhZGVycyA9IHNlcmlhbGl6ZUhlYWRlcnModHJhbnNwb3J0ZXIsIHJlcXVlc3RPcHRpb25zKTtcclxuICAgIGNvbnN0IG1ldGhvZCA9IHJlcXVlc3QubWV0aG9kO1xyXG4gICAgLy8gT24gYEdFVGAsIHRoZSBkYXRhIGlzIHByb3hpZWQgdG8gcXVlcnkgcGFyYW1ldGVycy5cclxuICAgIGNvbnN0IGRhdGFRdWVyeVBhcmFtZXRlcnMgPSByZXF1ZXN0Lm1ldGhvZCAhPT0gTWV0aG9kRW51bS5HZXRcclxuICAgICAgICA/IHt9XHJcbiAgICAgICAgOiB7XHJcbiAgICAgICAgICAgIC4uLnJlcXVlc3QuZGF0YSxcclxuICAgICAgICAgICAgLi4ucmVxdWVzdE9wdGlvbnMuZGF0YSxcclxuICAgICAgICB9O1xyXG4gICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge1xyXG4gICAgICAgICd4LWFsZ29saWEtYWdlbnQnOiB0cmFuc3BvcnRlci51c2VyQWdlbnQudmFsdWUsXHJcbiAgICAgICAgLi4udHJhbnNwb3J0ZXIucXVlcnlQYXJhbWV0ZXJzLFxyXG4gICAgICAgIC4uLmRhdGFRdWVyeVBhcmFtZXRlcnMsXHJcbiAgICAgICAgLi4ucmVxdWVzdE9wdGlvbnMucXVlcnlQYXJhbWV0ZXJzLFxyXG4gICAgfTtcclxuICAgIGxldCB0aW1lb3V0c0NvdW50ID0gMDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBmdW5jdGlvbmFsL25vLWxldFxyXG4gICAgY29uc3QgcmV0cnkgPSAoaG9zdHMsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZnVuY3Rpb25hbC9wcmVmZXItcmVhZG9ubHktdHlwZVxyXG4gICAgZ2V0VGltZW91dCkgPT4ge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdlIGl0ZXJhdGUgb24gZWFjaCBob3N0LCB1bnRpbCB0aGVyZSBpcyBubyBob3N0IGxlZnQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY29uc3QgaG9zdCA9IGhvc3RzLnBvcCgpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGZ1bmN0aW9uYWwvaW1tdXRhYmxlLWRhdGFcclxuICAgICAgICBpZiAoaG9zdCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRocm93IGNyZWF0ZVJldHJ5RXJyb3Ioc3RhY2tUcmFjZVdpdGhvdXRDcmVkZW50aWFscyhzdGFja1RyYWNlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7XHJcbiAgICAgICAgICAgIGRhdGEsXHJcbiAgICAgICAgICAgIGhlYWRlcnMsXHJcbiAgICAgICAgICAgIG1ldGhvZCxcclxuICAgICAgICAgICAgdXJsOiBzZXJpYWxpemVVcmwoaG9zdCwgcmVxdWVzdC5wYXRoLCBxdWVyeVBhcmFtZXRlcnMpLFxyXG4gICAgICAgICAgICBjb25uZWN0VGltZW91dDogZ2V0VGltZW91dCh0aW1lb3V0c0NvdW50LCB0cmFuc3BvcnRlci50aW1lb3V0cy5jb25uZWN0KSxcclxuICAgICAgICAgICAgcmVzcG9uc2VUaW1lb3V0OiBnZXRUaW1lb3V0KHRpbWVvdXRzQ291bnQsIHJlcXVlc3RPcHRpb25zLnRpbWVvdXQpLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHN0YWNrRnJhbWUgaXMgcHVzaGVkIHRvIHRoZSBzdGFja1RyYWNlIHNvIHdlXHJcbiAgICAgICAgICogY2FuIGhhdmUgaW5mb3JtYXRpb24gYWJvdXQgb25SZXRyeSBhbmQgb25GYWlsdXJlXHJcbiAgICAgICAgICogZGVjaXNpb25zLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNvbnN0IHB1c2hUb1N0YWNrVHJhY2UgPSAocmVzcG9uc2UpID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgc3RhY2tGcmFtZSA9IHtcclxuICAgICAgICAgICAgICAgIHJlcXVlc3Q6IHBheWxvYWQsXHJcbiAgICAgICAgICAgICAgICByZXNwb25zZSxcclxuICAgICAgICAgICAgICAgIGhvc3QsXHJcbiAgICAgICAgICAgICAgICB0cmllc0xlZnQ6IGhvc3RzLmxlbmd0aCxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmN0aW9uYWwvaW1tdXRhYmxlLWRhdGFcclxuICAgICAgICAgICAgc3RhY2tUcmFjZS5wdXNoKHN0YWNrRnJhbWUpO1xyXG4gICAgICAgICAgICByZXR1cm4gc3RhY2tGcmFtZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IGRlY2lzaW9ucyA9IHtcclxuICAgICAgICAgICAgb25TdWNjZXNzOiByZXNwb25zZSA9PiBkZXNlcmlhbGl6ZVN1Y2Nlc3MocmVzcG9uc2UpLFxyXG4gICAgICAgICAgICBvblJldHJ5KHJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFja0ZyYW1lID0gcHVzaFRvU3RhY2tUcmFjZShyZXNwb25zZSk7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIElmIHJlc3BvbnNlIGlzIGEgdGltZW91dCwgd2UgaW5jcmVhc2V0IHRoZSBudW1iZXIgb2ZcclxuICAgICAgICAgICAgICAgICAqIHRpbWVvdXRzIHNvIHdlIGNhbiBpbmNyZWFzZSB0aGUgdGltZW91dCBsYXRlci5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmlzVGltZWRPdXQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aW1lb3V0c0NvdW50Kys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xyXG4gICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEZhaWx1cmVzIGFyZSBpbmRpdmlkdWFsbHkgc2VuZCB0aGUgbG9nZ2VyLCBhbGxvd2luZ1xyXG4gICAgICAgICAgICAgICAgICAgICAqIHRoZSBlbmQgdXNlciB0byBkZWJ1ZyAvIHN0b3JlIHN0YWNrIGZyYW1lcyBldmVuXHJcbiAgICAgICAgICAgICAgICAgICAgICogd2hlbiBhIHJldHJ5IGVycm9yIGRvZXMgbm90IGhhcHBlbi5cclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICB0cmFuc3BvcnRlci5sb2dnZXIuaW5mbygnUmV0cnlhYmxlIGZhaWx1cmUnLCBzdGFja0ZyYW1lV2l0aG91dENyZWRlbnRpYWxzKHN0YWNrRnJhbWUpKSxcclxuICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICAgKiBXZSBhbHNvIHN0b3JlIHRoZSBzdGF0ZSBvZiB0aGUgaG9zdCBpbiBmYWlsdXJlIGNhc2VzLiBJZiB0aGUgaG9zdCwgaXNcclxuICAgICAgICAgICAgICAgICAgICAgKiBkb3duIGl0IHdpbGwgcmVtYWluIGRvd24gZm9yIHRoZSBuZXh0IDIgbWludXRlcy4gSW4gYSB0aW1lb3V0IHNpdHVhdGlvbixcclxuICAgICAgICAgICAgICAgICAgICAgKiB0aGlzIGhvc3Qgd2lsbCBiZSBhZGRlZCBlbmQgb2YgdGhlIGxpc3Qgb2YgaG9zdHMgb24gdGhlIG5leHQgcmVxdWVzdC5cclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICB0cmFuc3BvcnRlci5ob3N0c0NhY2hlLnNldChob3N0LCBjcmVhdGVTdGF0ZWZ1bEhvc3QoaG9zdCwgcmVzcG9uc2UuaXNUaW1lZE91dCA/IEhvc3RTdGF0dXNFbnVtLlRpbWVvdXRlZCA6IEhvc3RTdGF0dXNFbnVtLkRvd24pKSxcclxuICAgICAgICAgICAgICAgIF0pLnRoZW4oKCkgPT4gcmV0cnkoaG9zdHMsIGdldFRpbWVvdXQpKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgb25GYWlsKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgICAgICBwdXNoVG9TdGFja1RyYWNlKHJlc3BvbnNlKTtcclxuICAgICAgICAgICAgICAgIHRocm93IGRlc2VyaWFsaXplRmFpbHVyZShyZXNwb25zZSwgc3RhY2tUcmFjZVdpdGhvdXRDcmVkZW50aWFscyhzdGFja1RyYWNlKSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gdHJhbnNwb3J0ZXIucmVxdWVzdGVyLnNlbmQocGF5bG9hZCkudGhlbihyZXNwb25zZSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiByZXRyeURlY2lzaW9uKHJlc3BvbnNlLCBkZWNpc2lvbnMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogRmluYWxseSwgZm9yIGVhY2ggcmV0cnlhYmxlIGhvc3QgcGVyZm9ybSByZXF1ZXN0IHVudGlsIHdlIGdvdCBhIG5vblxyXG4gICAgICogcmV0cnlhYmxlIHJlc3BvbnNlLiBTb21lIG5vdGVzIGhlcmU6XHJcbiAgICAgKlxyXG4gICAgICogMS4gVGhlIHJldmVyc2UgaGVyZSBpcyBhcHBsaWVkIHNvIHdlIGNhbiBhcHBseSBhIGBwb3BgIGxhdGVyIG9uID0+IG1vcmUgcGVyZm9ybWFudC5cclxuICAgICAqIDIuIFdlIGFsc28gZ2V0IGZyb20gdGhlIHJldHJ5YWJsZSBvcHRpb25zIGEgdGltZW91dCBtdWx0aXBsaWVyIHRoYXQgaXMgdGFpbG9yZWRcclxuICAgICAqIGZvciB0aGUgY3VycmVudCBjb250ZXh0LlxyXG4gICAgICovXHJcbiAgICByZXR1cm4gY3JlYXRlUmV0cnlhYmxlT3B0aW9ucyh0cmFuc3BvcnRlci5ob3N0c0NhY2hlLCBzdGF0ZWxlc3NIb3N0cykudGhlbihvcHRpb25zID0+IHtcclxuICAgICAgICByZXR1cm4gcmV0cnkoWy4uLm9wdGlvbnMuc3RhdGVsZXNzSG9zdHNdLnJldmVyc2UoKSwgb3B0aW9ucy5nZXRUaW1lb3V0KTtcclxuICAgIH0pO1xyXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRyYW5zcG9ydGVyKG9wdGlvbnMpIHtcclxuICAgIGNvbnN0IHsgaG9zdHNDYWNoZSwgbG9nZ2VyLCByZXF1ZXN0ZXIsIHJlcXVlc3RzQ2FjaGUsIHJlc3BvbnNlc0NhY2hlLCB0aW1lb3V0cywgdXNlckFnZW50LCBob3N0cywgcXVlcnlQYXJhbWV0ZXJzLCBoZWFkZXJzLCB9ID0gb3B0aW9ucztcclxuICAgIGNvbnN0IHRyYW5zcG9ydGVyID0ge1xyXG4gICAgICAgIGhvc3RzQ2FjaGUsXHJcbiAgICAgICAgbG9nZ2VyLFxyXG4gICAgICAgIHJlcXVlc3RlcixcclxuICAgICAgICByZXF1ZXN0c0NhY2hlLFxyXG4gICAgICAgIHJlc3BvbnNlc0NhY2hlLFxyXG4gICAgICAgIHRpbWVvdXRzLFxyXG4gICAgICAgIHVzZXJBZ2VudCxcclxuICAgICAgICBoZWFkZXJzLFxyXG4gICAgICAgIHF1ZXJ5UGFyYW1ldGVycyxcclxuICAgICAgICBob3N0czogaG9zdHMubWFwKGhvc3QgPT4gY3JlYXRlU3RhdGVsZXNzSG9zdChob3N0KSksXHJcbiAgICAgICAgcmVhZChyZXF1ZXN0LCByZXF1ZXN0T3B0aW9ucykge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRmlyc3QsIHdlIGNvbXB1dGUgdGhlIHVzZXIgcmVxdWVzdCBvcHRpb25zLiBOb3csIGtlZXAgaW4gbWluZCxcclxuICAgICAgICAgICAgICogdGhhdCB1c2luZyByZXF1ZXN0IG9wdGlvbnMgdGhlIHVzZXIgaXMgYWJsZSB0byBtb2RpZmllZCB0aGUgaW50aXJlXHJcbiAgICAgICAgICAgICAqIHBheWxvYWQgb2YgdGhlIHJlcXVlc3QuIFN1Y2ggYXMgaGVhZGVycywgcXVlcnkgcGFyYW1ldGVycywgYW5kIG90aGVycy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGNvbnN0IG1hcHBlZFJlcXVlc3RPcHRpb25zID0gY3JlYXRlTWFwcGVkUmVxdWVzdE9wdGlvbnMocmVxdWVzdE9wdGlvbnMsIHRyYW5zcG9ydGVyLnRpbWVvdXRzLnJlYWQpO1xyXG4gICAgICAgICAgICBjb25zdCBjcmVhdGVSZXRyeWFibGVSZXF1ZXN0ID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBUaGVuLCB3ZSBwcmVwYXJlIGEgZnVuY3Rpb24gZmFjdG9yeSB0aGF0IGNvbnRhaW5zIHRoZSBjb25zdHJ1Y3Rpb24gb2ZcclxuICAgICAgICAgICAgICAgICAqIHRoZSByZXRyeWFibGUgcmVxdWVzdC4gQXQgdGhpcyBwb2ludCwgd2UgbWF5ICpub3QqIHBlcmZvcm0gdGhlIGFjdHVhbFxyXG4gICAgICAgICAgICAgICAgICogcmVxdWVzdC4gQnV0IHdlIHdhbnQgdG8gaGF2ZSB0aGUgZnVuY3Rpb24gZmFjdG9yeSByZWFkeS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldHJ5YWJsZVJlcXVlc3QodHJhbnNwb3J0ZXIsIHRyYW5zcG9ydGVyLmhvc3RzLmZpbHRlcihob3N0ID0+IChob3N0LmFjY2VwdCAmIENhbGxFbnVtLlJlYWQpICE9PSAwKSwgcmVxdWVzdCwgbWFwcGVkUmVxdWVzdE9wdGlvbnMpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogT25jZSB3ZSBoYXZlIHRoZSBmdW5jdGlvbiBmYWN0b3J5IHJlYWR5LCB3ZSBuZWVkIHRvIGRldGVybWluZSBvZiB0aGVcclxuICAgICAgICAgICAgICogcmVxdWVzdCBpcyBcImNhY2hlYWJsZVwiIC0gc2hvdWxkIGJlIGNhY2hlZC4gTm90ZSB0aGF0LCBvbmNlIGFnYWluLFxyXG4gICAgICAgICAgICAgKiB0aGUgdXNlciBjYW4gZm9yY2UgdGhpcyBvcHRpb24uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBjb25zdCBjYWNoZWFibGUgPSBtYXBwZWRSZXF1ZXN0T3B0aW9ucy5jYWNoZWFibGUgIT09IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgPyBtYXBwZWRSZXF1ZXN0T3B0aW9ucy5jYWNoZWFibGVcclxuICAgICAgICAgICAgICAgIDogcmVxdWVzdC5jYWNoZWFibGU7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBJZiBpcyBub3QgXCJjYWNoZWFibGVcIiwgd2UgaW1tZWRpYXRseSB0cmlnZ2VyIHRoZSByZXRyeWFibGUgcmVxdWVzdCwgbm9cclxuICAgICAgICAgICAgICogbmVlZCB0byBjaGVjayBjYWNoZSBpbXBsZW1lbnRhdGlvbnMuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBpZiAoY2FjaGVhYmxlICE9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlUmV0cnlhYmxlUmVxdWVzdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBJZiB0aGUgcmVxdWVzdCBpcyBcImNhY2hlYWJsZVwiLCB3ZSBuZWVkIHRvIGZpcnN0IGNvbXB1dGUgdGhlIGtleSB0byBhc2tcclxuICAgICAgICAgICAgICogdGhlIGNhY2hlIGltcGxlbWVudGF0aW9ucyBpZiB0aGlzIHJlcXVlc3QgaXMgb24gcHJvZ3Jlc3Mgb3IgaWYgdGhlXHJcbiAgICAgICAgICAgICAqIHJlc3BvbnNlIGFscmVhZHkgZXhpc3RzIG9uIHRoZSBjYWNoZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHtcclxuICAgICAgICAgICAgICAgIHJlcXVlc3QsXHJcbiAgICAgICAgICAgICAgICBtYXBwZWRSZXF1ZXN0T3B0aW9ucyxcclxuICAgICAgICAgICAgICAgIHRyYW5zcG9ydGVyOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzOiB0cmFuc3BvcnRlci5xdWVyeVBhcmFtZXRlcnMsXHJcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdHJhbnNwb3J0ZXIuaGVhZGVycyxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBXaXRoIHRoZSBjb21wdXRlZCBrZXksIHdlIGZpcnN0IGFzayB0aGUgcmVzcG9uc2VzIGNhY2hlXHJcbiAgICAgICAgICAgICAqIGltcGxlbWVudGlvbiBpZiB0aGlzIHJlcXVlc3Qgd2FzIGJlZW4gcmVzb2x2ZWQgYmVmb3JlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgcmV0dXJuIHRyYW5zcG9ydGVyLnJlc3BvbnNlc0NhY2hlLmdldChrZXksICgpID0+IHtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogSWYgdGhlIHJlcXVlc3QgaGFzIG5ldmVyIHJlc29sdmVkIGJlZm9yZSwgd2UgYWN0dWFsbHkgYXNrIGlmIHRoZXJlXHJcbiAgICAgICAgICAgICAgICAgKiBpcyBhIGN1cnJlbnQgcmVxdWVzdCB3aXRoIHRoZSBzYW1lIGtleSBvbiBwcm9ncmVzcy5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyYW5zcG9ydGVyLnJlcXVlc3RzQ2FjaGUuZ2V0KGtleSwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAodHJhbnNwb3J0ZXIucmVxdWVzdHNDYWNoZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICogRmluYWxseSwgaWYgdGhlcmUgaXMgbm8gcmVxdWVzdCBpbiBwcm9ncmVzcyB3aXRoIHRoZSBzYW1lIGtleSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICogdGhpcyBgY3JlYXRlUmV0cnlhYmxlUmVxdWVzdCgpYCB3aWxsIGFjdHVhbGx5IHRyaWdnZXIgdGhlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIHJldHJ5YWJsZSByZXF1ZXN0LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgLnNldChrZXksIGNyZWF0ZVJldHJ5YWJsZVJlcXVlc3QoKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4ocmVzcG9uc2UgPT4gUHJvbWlzZS5hbGwoW3RyYW5zcG9ydGVyLnJlcXVlc3RzQ2FjaGUuZGVsZXRlKGtleSksIHJlc3BvbnNlXSksIGVyciA9PiBQcm9taXNlLmFsbChbdHJhbnNwb3J0ZXIucmVxdWVzdHNDYWNoZS5kZWxldGUoa2V5KSwgUHJvbWlzZS5yZWplY3QoZXJyKV0pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbigoW18sIHJlc3BvbnNlXSkgPT4gcmVzcG9uc2UpKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9LCB7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIE9mIGNvdXJzZSwgb25jZSB3ZSBnZXQgdGhpcyByZXNwb25zZSBiYWNrIGZyb20gdGhlIHNlcnZlciwgd2VcclxuICAgICAgICAgICAgICAgICAqIHRlbGwgcmVzcG9uc2UgY2FjaGUgdG8gYWN0dWFsbHkgc3RvcmUgdGhlIHJlY2VpdmVkIHJlc3BvbnNlXHJcbiAgICAgICAgICAgICAgICAgKiB0byBiZSB1c2VkIGxhdGVyLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBtaXNzOiByZXNwb25zZSA9PiB0cmFuc3BvcnRlci5yZXNwb25zZXNDYWNoZS5zZXQoa2V5LCByZXNwb25zZSksXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgd3JpdGUocmVxdWVzdCwgcmVxdWVzdE9wdGlvbnMpIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIE9uIHdyaXRlIHJlcXVlc3RzLCBubyBjYWNoZSBtZWNoYW5pc21zIGFyZSBhcHBsaWVkLCBhbmQgd2VcclxuICAgICAgICAgICAgICogcHJveHkgdGhlIHJlcXVlc3QgaW1tZWRpYXRlbHkgdG8gdGhlIHJlcXVlc3Rlci5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHJldHVybiByZXRyeWFibGVSZXF1ZXN0KHRyYW5zcG9ydGVyLCB0cmFuc3BvcnRlci5ob3N0cy5maWx0ZXIoaG9zdCA9PiAoaG9zdC5hY2NlcHQgJiBDYWxsRW51bS5Xcml0ZSkgIT09IDApLCByZXF1ZXN0LCBjcmVhdGVNYXBwZWRSZXF1ZXN0T3B0aW9ucyhyZXF1ZXN0T3B0aW9ucywgdHJhbnNwb3J0ZXIudGltZW91dHMud3JpdGUpKTtcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxuICAgIHJldHVybiB0cmFuc3BvcnRlcjtcclxufVxuXG5mdW5jdGlvbiBjcmVhdGVVc2VyQWdlbnQodmVyc2lvbikge1xyXG4gICAgY29uc3QgdXNlckFnZW50ID0ge1xyXG4gICAgICAgIHZhbHVlOiBgQWxnb2xpYSBmb3IgSmF2YVNjcmlwdCAoJHt2ZXJzaW9ufSlgLFxyXG4gICAgICAgIGFkZChvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGFkZGVkVXNlckFnZW50ID0gYDsgJHtvcHRpb25zLnNlZ21lbnR9JHtvcHRpb25zLnZlcnNpb24gIT09IHVuZGVmaW5lZCA/IGAgKCR7b3B0aW9ucy52ZXJzaW9ufSlgIDogJyd9YDtcclxuICAgICAgICAgICAgaWYgKHVzZXJBZ2VudC52YWx1ZS5pbmRleE9mKGFkZGVkVXNlckFnZW50KSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jdGlvbmFsL2ltbXV0YWJsZS1kYXRhXHJcbiAgICAgICAgICAgICAgICB1c2VyQWdlbnQudmFsdWUgPSBgJHt1c2VyQWdlbnQudmFsdWV9JHthZGRlZFVzZXJBZ2VudH1gO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB1c2VyQWdlbnQ7XHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbiAgICByZXR1cm4gdXNlckFnZW50O1xyXG59XG5cbmZ1bmN0aW9uIGRlc2VyaWFsaXplU3VjY2VzcyhyZXNwb25zZSkge1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmN0aW9uYWwvbm8tdHJ5LXN0YXRlbWVudFxyXG4gICAgdHJ5IHtcclxuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShyZXNwb25zZS5jb250ZW50KTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgdGhyb3cgY3JlYXRlRGVzZXJpYWxpemF0aW9uRXJyb3IoZS5tZXNzYWdlLCByZXNwb25zZSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZGVzZXJpYWxpemVGYWlsdXJlKHsgY29udGVudCwgc3RhdHVzIH0sIHN0YWNrRnJhbWUpIHtcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jdGlvbmFsL25vLWxldFxyXG4gICAgbGV0IG1lc3NhZ2UgPSBjb250ZW50O1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmN0aW9uYWwvbm8tdHJ5LXN0YXRlbWVudFxyXG4gICAgdHJ5IHtcclxuICAgICAgICBtZXNzYWdlID0gSlNPTi5wYXJzZShjb250ZW50KS5tZXNzYWdlO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAvLyAuLlxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNyZWF0ZUFwaUVycm9yKG1lc3NhZ2UsIHN0YXR1cywgc3RhY2tGcmFtZSk7XHJcbn1cblxuZnVuY3Rpb24gc2VyaWFsaXplVXJsKGhvc3QsIHBhdGgsIHF1ZXJ5UGFyYW1ldGVycykge1xyXG4gICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzQXNTdHJpbmcgPSBzZXJpYWxpemVRdWVyeVBhcmFtZXRlcnMocXVlcnlQYXJhbWV0ZXJzKTtcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jdGlvbmFsL25vLWxldFxyXG4gICAgbGV0IHVybCA9IGAke2hvc3QucHJvdG9jb2x9Oi8vJHtob3N0LnVybH0vJHtwYXRoLmNoYXJBdCgwKSA9PT0gJy8nID8gcGF0aC5zdWJzdHIoMSkgOiBwYXRofWA7XHJcbiAgICBpZiAocXVlcnlQYXJhbWV0ZXJzQXNTdHJpbmcubGVuZ3RoKSB7XHJcbiAgICAgICAgdXJsICs9IGA/JHtxdWVyeVBhcmFtZXRlcnNBc1N0cmluZ31gO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHVybDtcclxufVxyXG5mdW5jdGlvbiBzZXJpYWxpemVRdWVyeVBhcmFtZXRlcnMocGFyYW1ldGVycykge1xyXG4gICAgY29uc3QgaXNPYmplY3RPckFycmF5ID0gKHZhbHVlKSA9PiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBPYmplY3RdJyB8fFxyXG4gICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IEFycmF5XSc7XHJcbiAgICByZXR1cm4gT2JqZWN0LmtleXMocGFyYW1ldGVycylcclxuICAgICAgICAubWFwKGtleSA9PiBlbmNvZGUoJyVzPSVzJywga2V5LCBpc09iamVjdE9yQXJyYXkocGFyYW1ldGVyc1trZXldKSA/IEpTT04uc3RyaW5naWZ5KHBhcmFtZXRlcnNba2V5XSkgOiBwYXJhbWV0ZXJzW2tleV0pKVxyXG4gICAgICAgIC5qb2luKCcmJyk7XHJcbn1cclxuZnVuY3Rpb24gc2VyaWFsaXplRGF0YShyZXF1ZXN0LCByZXF1ZXN0T3B0aW9ucykge1xyXG4gICAgaWYgKHJlcXVlc3QubWV0aG9kID09PSBNZXRob2RFbnVtLkdldCB8fFxyXG4gICAgICAgIChyZXF1ZXN0LmRhdGEgPT09IHVuZGVmaW5lZCAmJiByZXF1ZXN0T3B0aW9ucy5kYXRhID09PSB1bmRlZmluZWQpKSB7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIGNvbnN0IGRhdGEgPSBBcnJheS5pc0FycmF5KHJlcXVlc3QuZGF0YSlcclxuICAgICAgICA/IHJlcXVlc3QuZGF0YVxyXG4gICAgICAgIDogeyAuLi5yZXF1ZXN0LmRhdGEsIC4uLnJlcXVlc3RPcHRpb25zLmRhdGEgfTtcclxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShkYXRhKTtcclxufVxyXG5mdW5jdGlvbiBzZXJpYWxpemVIZWFkZXJzKHRyYW5zcG9ydGVyLCByZXF1ZXN0T3B0aW9ucykge1xyXG4gICAgY29uc3QgaGVhZGVycyA9IHtcclxuICAgICAgICAuLi50cmFuc3BvcnRlci5oZWFkZXJzLFxyXG4gICAgICAgIC4uLnJlcXVlc3RPcHRpb25zLmhlYWRlcnMsXHJcbiAgICB9O1xyXG4gICAgY29uc3Qgc2VyaWFsaXplZEhlYWRlcnMgPSB7fTtcclxuICAgIE9iamVjdC5rZXlzKGhlYWRlcnMpLmZvckVhY2goaGVhZGVyID0+IHtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IGhlYWRlcnNbaGVhZGVyXTtcclxuICAgICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmN0aW9uYWwvaW1tdXRhYmxlLWRhdGFcclxuICAgICAgICBzZXJpYWxpemVkSGVhZGVyc1toZWFkZXIudG9Mb3dlckNhc2UoKV0gPSB2YWx1ZTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHNlcmlhbGl6ZWRIZWFkZXJzO1xyXG59XG5cbmZ1bmN0aW9uIHN0YWNrVHJhY2VXaXRob3V0Q3JlZGVudGlhbHMoc3RhY2tUcmFjZSkge1xyXG4gICAgcmV0dXJuIHN0YWNrVHJhY2UubWFwKHN0YWNrRnJhbWUgPT4gc3RhY2tGcmFtZVdpdGhvdXRDcmVkZW50aWFscyhzdGFja0ZyYW1lKSk7XHJcbn1cclxuZnVuY3Rpb24gc3RhY2tGcmFtZVdpdGhvdXRDcmVkZW50aWFscyhzdGFja0ZyYW1lKSB7XHJcbiAgICBjb25zdCBtb2RpZmllZEhlYWRlcnMgPSBzdGFja0ZyYW1lLnJlcXVlc3QuaGVhZGVyc1sneC1hbGdvbGlhLWFwaS1rZXknXVxyXG4gICAgICAgID8geyAneC1hbGdvbGlhLWFwaS1rZXknOiAnKioqKionIH1cclxuICAgICAgICA6IHt9O1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICAuLi5zdGFja0ZyYW1lLFxyXG4gICAgICAgIHJlcXVlc3Q6IHtcclxuICAgICAgICAgICAgLi4uc3RhY2tGcmFtZS5yZXF1ZXN0LFxyXG4gICAgICAgICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgICAgICAgICAuLi5zdGFja0ZyYW1lLnJlcXVlc3QuaGVhZGVycyxcclxuICAgICAgICAgICAgICAgIC4uLm1vZGlmaWVkSGVhZGVycyxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxuXG5mdW5jdGlvbiBjcmVhdGVBcGlFcnJvcihtZXNzYWdlLCBzdGF0dXMsIHRyYW5zcG9ydGVyU3RhY2tUcmFjZSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBuYW1lOiAnQXBpRXJyb3InLFxyXG4gICAgICAgIG1lc3NhZ2UsXHJcbiAgICAgICAgc3RhdHVzLFxyXG4gICAgICAgIHRyYW5zcG9ydGVyU3RhY2tUcmFjZSxcclxuICAgIH07XHJcbn1cblxuZnVuY3Rpb24gY3JlYXRlRGVzZXJpYWxpemF0aW9uRXJyb3IobWVzc2FnZSwgcmVzcG9uc2UpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbmFtZTogJ0Rlc2VyaWFsaXphdGlvbkVycm9yJyxcclxuICAgICAgICBtZXNzYWdlLFxyXG4gICAgICAgIHJlc3BvbnNlLFxyXG4gICAgfTtcclxufVxuXG5mdW5jdGlvbiBjcmVhdGVSZXRyeUVycm9yKHRyYW5zcG9ydGVyU3RhY2tUcmFjZSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBuYW1lOiAnUmV0cnlFcnJvcicsXHJcbiAgICAgICAgbWVzc2FnZTogJ1VucmVhY2hhYmxlIGhvc3RzIC0geW91ciBhcHBsaWNhdGlvbiBpZCBtYXkgYmUgaW5jb3JyZWN0LiBJZiB0aGUgZXJyb3IgcGVyc2lzdHMsIGNvbnRhY3Qgc3VwcG9ydEBhbGdvbGlhLmNvbS4nLFxyXG4gICAgICAgIHRyYW5zcG9ydGVyU3RhY2tUcmFjZSxcclxuICAgIH07XHJcbn1cblxuY29uc3QgY3JlYXRlU2VhcmNoQ2xpZW50ID0gb3B0aW9ucyA9PiB7XHJcbiAgICBjb25zdCBhcHBJZCA9IG9wdGlvbnMuYXBwSWQ7XHJcbiAgICBjb25zdCBhdXRoID0gY3JlYXRlQXV0aChvcHRpb25zLmF1dGhNb2RlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmF1dGhNb2RlIDogQXV0aE1vZGUuV2l0aGluSGVhZGVycywgYXBwSWQsIG9wdGlvbnMuYXBpS2V5KTtcclxuICAgIGNvbnN0IHRyYW5zcG9ydGVyID0gY3JlYXRlVHJhbnNwb3J0ZXIoe1xyXG4gICAgICAgIGhvc3RzOiBbXHJcbiAgICAgICAgICAgIHsgdXJsOiBgJHthcHBJZH0tZHNuLmFsZ29saWEubmV0YCwgYWNjZXB0OiBDYWxsRW51bS5SZWFkIH0sXHJcbiAgICAgICAgICAgIHsgdXJsOiBgJHthcHBJZH0uYWxnb2xpYS5uZXRgLCBhY2NlcHQ6IENhbGxFbnVtLldyaXRlIH0sXHJcbiAgICAgICAgXS5jb25jYXQoc2h1ZmZsZShbXHJcbiAgICAgICAgICAgIHsgdXJsOiBgJHthcHBJZH0tMS5hbGdvbGlhbmV0LmNvbWAgfSxcclxuICAgICAgICAgICAgeyB1cmw6IGAke2FwcElkfS0yLmFsZ29saWFuZXQuY29tYCB9LFxyXG4gICAgICAgICAgICB7IHVybDogYCR7YXBwSWR9LTMuYWxnb2xpYW5ldC5jb21gIH0sXHJcbiAgICAgICAgXSkpLFxyXG4gICAgICAgIC4uLm9wdGlvbnMsXHJcbiAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgICAuLi5hdXRoLmhlYWRlcnMoKSxcclxuICAgICAgICAgICAgLi4ueyAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcgfSxcclxuICAgICAgICAgICAgLi4ub3B0aW9ucy5oZWFkZXJzLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcXVlcnlQYXJhbWV0ZXJzOiB7XHJcbiAgICAgICAgICAgIC4uLmF1dGgucXVlcnlQYXJhbWV0ZXJzKCksXHJcbiAgICAgICAgICAgIC4uLm9wdGlvbnMucXVlcnlQYXJhbWV0ZXJzLFxyXG4gICAgICAgIH0sXHJcbiAgICB9KTtcclxuICAgIGNvbnN0IGJhc2UgPSB7XHJcbiAgICAgICAgdHJhbnNwb3J0ZXIsXHJcbiAgICAgICAgYXBwSWQsXHJcbiAgICAgICAgYWRkQWxnb2xpYUFnZW50KHNlZ21lbnQsIHZlcnNpb24pIHtcclxuICAgICAgICAgICAgdHJhbnNwb3J0ZXIudXNlckFnZW50LmFkZCh7IHNlZ21lbnQsIHZlcnNpb24gfSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjbGVhckNhY2hlKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xyXG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0ZXIucmVxdWVzdHNDYWNoZS5jbGVhcigpLFxyXG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0ZXIucmVzcG9uc2VzQ2FjaGUuY2xlYXIoKSxcclxuICAgICAgICAgICAgXSkudGhlbigoKSA9PiB1bmRlZmluZWQpO1xyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGFkZE1ldGhvZHMoYmFzZSwgb3B0aW9ucy5tZXRob2RzKTtcclxufTtcblxuY29uc3QgY3VzdG9tUmVxdWVzdCA9IChiYXNlKSA9PiB7XHJcbiAgICByZXR1cm4gKHJlcXVlc3QsIHJlcXVlc3RPcHRpb25zKSA9PiB7XHJcbiAgICAgICAgaWYgKHJlcXVlc3QubWV0aG9kID09PSBNZXRob2RFbnVtLkdldCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYmFzZS50cmFuc3BvcnRlci5yZWFkKHJlcXVlc3QsIHJlcXVlc3RPcHRpb25zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGJhc2UudHJhbnNwb3J0ZXIud3JpdGUocmVxdWVzdCwgcmVxdWVzdE9wdGlvbnMpO1xyXG4gICAgfTtcclxufTtcblxuY29uc3QgaW5pdEluZGV4ID0gKGJhc2UpID0+IHtcclxuICAgIHJldHVybiAoaW5kZXhOYW1lLCBvcHRpb25zID0ge30pID0+IHtcclxuICAgICAgICBjb25zdCBzZWFyY2hJbmRleCA9IHtcclxuICAgICAgICAgICAgdHJhbnNwb3J0ZXI6IGJhc2UudHJhbnNwb3J0ZXIsXHJcbiAgICAgICAgICAgIGFwcElkOiBiYXNlLmFwcElkLFxyXG4gICAgICAgICAgICBpbmRleE5hbWUsXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gYWRkTWV0aG9kcyhzZWFyY2hJbmRleCwgb3B0aW9ucy5tZXRob2RzKTtcclxuICAgIH07XHJcbn07XG5cbmNvbnN0IG11bHRpcGxlUXVlcmllcyA9IChiYXNlKSA9PiB7XHJcbiAgICByZXR1cm4gKHF1ZXJpZXMsIHJlcXVlc3RPcHRpb25zKSA9PiB7XHJcbiAgICAgICAgY29uc3QgcmVxdWVzdHMgPSBxdWVyaWVzLm1hcChxdWVyeSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAuLi5xdWVyeSxcclxuICAgICAgICAgICAgICAgIHBhcmFtczogc2VyaWFsaXplUXVlcnlQYXJhbWV0ZXJzKHF1ZXJ5LnBhcmFtcyB8fCB7fSksXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGJhc2UudHJhbnNwb3J0ZXIucmVhZCh7XHJcbiAgICAgICAgICAgIG1ldGhvZDogTWV0aG9kRW51bS5Qb3N0LFxyXG4gICAgICAgICAgICBwYXRoOiAnMS9pbmRleGVzLyovcXVlcmllcycsXHJcbiAgICAgICAgICAgIGRhdGE6IHtcclxuICAgICAgICAgICAgICAgIHJlcXVlc3RzLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBjYWNoZWFibGU6IHRydWUsXHJcbiAgICAgICAgfSwgcmVxdWVzdE9wdGlvbnMpO1xyXG4gICAgfTtcclxufTtcblxuY29uc3QgbXVsdGlwbGVTZWFyY2hGb3JGYWNldFZhbHVlcyA9IChiYXNlKSA9PiB7XHJcbiAgICByZXR1cm4gKHF1ZXJpZXMsIHJlcXVlc3RPcHRpb25zKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHF1ZXJpZXMubWFwKHF1ZXJ5ID0+IHtcclxuICAgICAgICAgICAgY29uc3QgeyBmYWNldE5hbWUsIGZhY2V0UXVlcnksIC4uLnBhcmFtcyB9ID0gcXVlcnkucGFyYW1zO1xyXG4gICAgICAgICAgICByZXR1cm4gaW5pdEluZGV4KGJhc2UpKHF1ZXJ5LmluZGV4TmFtZSwge1xyXG4gICAgICAgICAgICAgICAgbWV0aG9kczogeyBzZWFyY2hGb3JGYWNldFZhbHVlcyB9LFxyXG4gICAgICAgICAgICB9KS5zZWFyY2hGb3JGYWNldFZhbHVlcyhmYWNldE5hbWUsIGZhY2V0UXVlcnksIHtcclxuICAgICAgICAgICAgICAgIC4uLnJlcXVlc3RPcHRpb25zLFxyXG4gICAgICAgICAgICAgICAgLi4ucGFyYW1zLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KSk7XHJcbiAgICB9O1xyXG59O1xuXG5jb25zdCBmaW5kQW5zd2VycyA9IChiYXNlKSA9PiB7XHJcbiAgICByZXR1cm4gKHF1ZXJ5LCBxdWVyeUxhbmd1YWdlcywgcmVxdWVzdE9wdGlvbnMpID0+IHtcclxuICAgICAgICByZXR1cm4gYmFzZS50cmFuc3BvcnRlci5yZWFkKHtcclxuICAgICAgICAgICAgbWV0aG9kOiBNZXRob2RFbnVtLlBvc3QsXHJcbiAgICAgICAgICAgIHBhdGg6IGVuY29kZSgnMS9hbnN3ZXJzLyVzL3ByZWRpY3Rpb24nLCBiYXNlLmluZGV4TmFtZSksXHJcbiAgICAgICAgICAgIGRhdGE6IHtcclxuICAgICAgICAgICAgICAgIHF1ZXJ5LFxyXG4gICAgICAgICAgICAgICAgcXVlcnlMYW5ndWFnZXMsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNhY2hlYWJsZTogdHJ1ZSxcclxuICAgICAgICB9LCByZXF1ZXN0T3B0aW9ucyk7XHJcbiAgICB9O1xyXG59O1xuXG5jb25zdCBzZWFyY2ggPSAoYmFzZSkgPT4ge1xyXG4gICAgcmV0dXJuIChxdWVyeSwgcmVxdWVzdE9wdGlvbnMpID0+IHtcclxuICAgICAgICByZXR1cm4gYmFzZS50cmFuc3BvcnRlci5yZWFkKHtcclxuICAgICAgICAgICAgbWV0aG9kOiBNZXRob2RFbnVtLlBvc3QsXHJcbiAgICAgICAgICAgIHBhdGg6IGVuY29kZSgnMS9pbmRleGVzLyVzL3F1ZXJ5JywgYmFzZS5pbmRleE5hbWUpLFxyXG4gICAgICAgICAgICBkYXRhOiB7XHJcbiAgICAgICAgICAgICAgICBxdWVyeSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY2FjaGVhYmxlOiB0cnVlLFxyXG4gICAgICAgIH0sIHJlcXVlc3RPcHRpb25zKTtcclxuICAgIH07XHJcbn07XG5cbmNvbnN0IHNlYXJjaEZvckZhY2V0VmFsdWVzID0gKGJhc2UpID0+IHtcclxuICAgIHJldHVybiAoZmFjZXROYW1lLCBmYWNldFF1ZXJ5LCByZXF1ZXN0T3B0aW9ucykgPT4ge1xyXG4gICAgICAgIHJldHVybiBiYXNlLnRyYW5zcG9ydGVyLnJlYWQoe1xyXG4gICAgICAgICAgICBtZXRob2Q6IE1ldGhvZEVudW0uUG9zdCxcclxuICAgICAgICAgICAgcGF0aDogZW5jb2RlKCcxL2luZGV4ZXMvJXMvZmFjZXRzLyVzL3F1ZXJ5JywgYmFzZS5pbmRleE5hbWUsIGZhY2V0TmFtZSksXHJcbiAgICAgICAgICAgIGRhdGE6IHtcclxuICAgICAgICAgICAgICAgIGZhY2V0UXVlcnksXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNhY2hlYWJsZTogdHJ1ZSxcclxuICAgICAgICB9LCByZXF1ZXN0T3B0aW9ucyk7XHJcbiAgICB9O1xyXG59O1xuXG5jb25zdCBMb2dMZXZlbEVudW0gPSB7XHJcbiAgICBEZWJ1ZzogMSxcclxuICAgIEluZm86IDIsXHJcbiAgICBFcnJvcjogMyxcclxufTtcblxuLyogZXNsaW50IG5vLWNvbnNvbGU6IDAgKi9cclxuZnVuY3Rpb24gY3JlYXRlQ29uc29sZUxvZ2dlcihsb2dMZXZlbCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBkZWJ1ZyhtZXNzYWdlLCBhcmdzKSB7XHJcbiAgICAgICAgICAgIGlmIChMb2dMZXZlbEVudW0uRGVidWcgPj0gbG9nTGV2ZWwpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcobWVzc2FnZSwgYXJncyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaW5mbyhtZXNzYWdlLCBhcmdzKSB7XHJcbiAgICAgICAgICAgIGlmIChMb2dMZXZlbEVudW0uSW5mbyA+PSBsb2dMZXZlbCkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5pbmZvKG1lc3NhZ2UsIGFyZ3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVycm9yKG1lc3NhZ2UsIGFyZ3MpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlLCBhcmdzKTtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUJyb3dzZXJYaHJSZXF1ZXN0ZXIoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHNlbmQocmVxdWVzdCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJhc2VSZXF1ZXN0ZXIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuICAgICAgICAgICAgICAgIGJhc2VSZXF1ZXN0ZXIub3BlbihyZXF1ZXN0Lm1ldGhvZCwgcmVxdWVzdC51cmwsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMocmVxdWVzdC5oZWFkZXJzKS5mb3JFYWNoKGtleSA9PiBiYXNlUmVxdWVzdGVyLnNldFJlcXVlc3RIZWFkZXIoa2V5LCByZXF1ZXN0LmhlYWRlcnNba2V5XSkpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY3JlYXRlVGltZW91dCA9ICh0aW1lb3V0LCBjb250ZW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiYXNlUmVxdWVzdGVyLmFib3J0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzVGltZWRPdXQ6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sIHRpbWVvdXQgKiAxMDAwKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb25uZWN0VGltZW91dCA9IGNyZWF0ZVRpbWVvdXQocmVxdWVzdC5jb25uZWN0VGltZW91dCwgJ0Nvbm5lY3Rpb24gdGltZW91dCcpO1xyXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmN0aW9uYWwvbm8tbGV0XHJcbiAgICAgICAgICAgICAgICBsZXQgcmVzcG9uc2VUaW1lb3V0O1xyXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmN0aW9uYWwvaW1tdXRhYmxlLWRhdGFcclxuICAgICAgICAgICAgICAgIGJhc2VSZXF1ZXN0ZXIub25yZWFkeXN0YXRlY2hhbmdlID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChiYXNlUmVxdWVzdGVyLnJlYWR5U3RhdGUgPiBiYXNlUmVxdWVzdGVyLk9QRU5FRCAmJiByZXNwb25zZVRpbWVvdXQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoY29ubmVjdFRpbWVvdXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZVRpbWVvdXQgPSBjcmVhdGVUaW1lb3V0KHJlcXVlc3QucmVzcG9uc2VUaW1lb3V0LCAnU29ja2V0IHRpbWVvdXQnKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmN0aW9uYWwvaW1tdXRhYmxlLWRhdGFcclxuICAgICAgICAgICAgICAgIGJhc2VSZXF1ZXN0ZXIub25lcnJvciA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChiYXNlUmVxdWVzdGVyLnN0YXR1cyA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoY29ubmVjdFRpbWVvdXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQocmVzcG9uc2VUaW1lb3V0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBiYXNlUmVxdWVzdGVyLnJlc3BvbnNlVGV4dCB8fCAnTmV0d29yayByZXF1ZXN0IGZhaWxlZCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IGJhc2VSZXF1ZXN0ZXIuc3RhdHVzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNUaW1lZE91dDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvLyAgZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmN0aW9uYWwvaW1tdXRhYmxlLWRhdGFcclxuICAgICAgICAgICAgICAgIGJhc2VSZXF1ZXN0ZXIub25sb2FkID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChjb25uZWN0VGltZW91dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHJlc3BvbnNlVGltZW91dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGJhc2VSZXF1ZXN0ZXIucmVzcG9uc2VUZXh0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IGJhc2VSZXF1ZXN0ZXIuc3RhdHVzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1RpbWVkT3V0OiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBiYXNlUmVxdWVzdGVyLnNlbmQocmVxdWVzdC5kYXRhKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbn1cblxuZnVuY3Rpb24gYWxnb2xpYXNlYXJjaChhcHBJZCwgYXBpS2V5LCBvcHRpb25zKSB7XHJcbiAgICBjb25zdCBjb21tb25PcHRpb25zID0ge1xyXG4gICAgICAgIGFwcElkLFxyXG4gICAgICAgIGFwaUtleSxcclxuICAgICAgICB0aW1lb3V0czoge1xyXG4gICAgICAgICAgICBjb25uZWN0OiAxLFxyXG4gICAgICAgICAgICByZWFkOiAyLFxyXG4gICAgICAgICAgICB3cml0ZTogMzAsXHJcbiAgICAgICAgfSxcclxuICAgICAgICByZXF1ZXN0ZXI6IGNyZWF0ZUJyb3dzZXJYaHJSZXF1ZXN0ZXIoKSxcclxuICAgICAgICBsb2dnZXI6IGNyZWF0ZUNvbnNvbGVMb2dnZXIoTG9nTGV2ZWxFbnVtLkVycm9yKSxcclxuICAgICAgICByZXNwb25zZXNDYWNoZTogY3JlYXRlSW5NZW1vcnlDYWNoZSgpLFxyXG4gICAgICAgIHJlcXVlc3RzQ2FjaGU6IGNyZWF0ZUluTWVtb3J5Q2FjaGUoeyBzZXJpYWxpemFibGU6IGZhbHNlIH0pLFxyXG4gICAgICAgIGhvc3RzQ2FjaGU6IGNyZWF0ZUZhbGxiYWNrYWJsZUNhY2hlKHtcclxuICAgICAgICAgICAgY2FjaGVzOiBbXHJcbiAgICAgICAgICAgICAgICBjcmVhdGVCcm93c2VyTG9jYWxTdG9yYWdlQ2FjaGUoeyBrZXk6IGAke3ZlcnNpb259LSR7YXBwSWR9YCB9KSxcclxuICAgICAgICAgICAgICAgIGNyZWF0ZUluTWVtb3J5Q2FjaGUoKSxcclxuICAgICAgICAgICAgXSxcclxuICAgICAgICB9KSxcclxuICAgICAgICB1c2VyQWdlbnQ6IGNyZWF0ZVVzZXJBZ2VudCh2ZXJzaW9uKS5hZGQoe1xyXG4gICAgICAgICAgICBzZWdtZW50OiAnQnJvd3NlcicsXHJcbiAgICAgICAgICAgIHZlcnNpb246ICdsaXRlJyxcclxuICAgICAgICB9KSxcclxuICAgICAgICBhdXRoTW9kZTogQXV0aE1vZGUuV2l0aGluUXVlcnlQYXJhbWV0ZXJzLFxyXG4gICAgfTtcclxuICAgIHJldHVybiBjcmVhdGVTZWFyY2hDbGllbnQoe1xyXG4gICAgICAgIC4uLmNvbW1vbk9wdGlvbnMsXHJcbiAgICAgICAgLi4ub3B0aW9ucyxcclxuICAgICAgICBtZXRob2RzOiB7XHJcbiAgICAgICAgICAgIHNlYXJjaDogbXVsdGlwbGVRdWVyaWVzLFxyXG4gICAgICAgICAgICBzZWFyY2hGb3JGYWNldFZhbHVlczogbXVsdGlwbGVTZWFyY2hGb3JGYWNldFZhbHVlcyxcclxuICAgICAgICAgICAgbXVsdGlwbGVRdWVyaWVzLFxyXG4gICAgICAgICAgICBtdWx0aXBsZVNlYXJjaEZvckZhY2V0VmFsdWVzLFxyXG4gICAgICAgICAgICBjdXN0b21SZXF1ZXN0LFxyXG4gICAgICAgICAgICBpbml0SW5kZXg6IGJhc2UgPT4gKGluZGV4TmFtZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGluaXRJbmRleChiYXNlKShpbmRleE5hbWUsIHtcclxuICAgICAgICAgICAgICAgICAgICBtZXRob2RzOiB7IHNlYXJjaCwgc2VhcmNoRm9yRmFjZXRWYWx1ZXMsIGZpbmRBbnN3ZXJzIH0sXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9LFxyXG4gICAgfSk7XHJcbn1cclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmN0aW9uYWwvaW1tdXRhYmxlLWRhdGFcclxuYWxnb2xpYXNlYXJjaC52ZXJzaW9uID0gdmVyc2lvbjtcblxuZXhwb3J0IGRlZmF1bHQgYWxnb2xpYXNlYXJjaDtcbiJdLCJuYW1lcyI6WyJjcmVhdGVCcm93c2VyTG9jYWxTdG9yYWdlQ2FjaGUiLCJvcHRpb25zIiwibmFtZXNwYWNlS2V5Iiwia2V5Iiwic3RvcmFnZSIsImdldFN0b3JhZ2UiLCJ1bmRlZmluZWQiLCJsb2NhbFN0b3JhZ2UiLCJ3aW5kb3ciLCJnZXROYW1lc3BhY2UiLCJKU09OIiwicGFyc2UiLCJnZXRJdGVtIiwic2V0TmFtZXNwYWNlIiwibmFtZXNwYWNlIiwic2V0SXRlbSIsInN0cmluZ2lmeSIsInJlbW92ZU91dGRhdGVkQ2FjaGVJdGVtcyIsInRpbWVUb0xpdmUiLCJmaWx0ZXJlZE5hbWVzcGFjZVdpdGhvdXRPbGRGb3JtYXR0ZWRDYWNoZUl0ZW1zIiwiT2JqZWN0IiwiZnJvbUVudHJpZXMiLCJlbnRyaWVzIiwiZmlsdGVyIiwiY2FjaGVJdGVtIiwidGltZXN0YW1wIiwiZmlsdGVyZWROYW1lc3BhY2VXaXRob3V0RXhwaXJlZEl0ZW1zIiwiY3VycmVudFRpbWVzdGFtcCIsIkRhdGUiLCJnZXRUaW1lIiwiaXNFeHBpcmVkIiwiZ2V0IiwiZGVmYXVsdFZhbHVlIiwiZXZlbnRzIiwibWlzcyIsIlByb21pc2UiLCJyZXNvbHZlIiwidGhlbiIsImtleUFzU3RyaW5nIiwidmFsdWUiLCJhbGwiLCJleGlzdHMiLCJzZXQiLCJkZWxldGUiLCJjbGVhciIsInJlbW92ZUl0ZW0iLCJjcmVhdGVGYWxsYmFja2FibGVDYWNoZSIsImNhY2hlcyIsImN1cnJlbnQiLCJzaGlmdCIsImNyZWF0ZU51bGxDYWNoZSIsImNhdGNoIiwiX2tleSIsInJlc3VsdCIsImNyZWF0ZUluTWVtb3J5Q2FjaGUiLCJzZXJpYWxpemFibGUiLCJjYWNoZSIsInByb21pc2UiLCJjcmVhdGVBdXRoIiwiYXV0aE1vZGUiLCJhcHBJZCIsImFwaUtleSIsImNyZWRlbnRpYWxzIiwiaGVhZGVycyIsIkF1dGhNb2RlIiwiV2l0aGluSGVhZGVycyIsInF1ZXJ5UGFyYW1ldGVycyIsIldpdGhpblF1ZXJ5UGFyYW1ldGVycyIsInNodWZmbGUiLCJhcnJheSIsImMiLCJsZW5ndGgiLCJiIiwiTWF0aCIsImZsb29yIiwicmFuZG9tIiwiYSIsImFkZE1ldGhvZHMiLCJiYXNlIiwibWV0aG9kcyIsImtleXMiLCJmb3JFYWNoIiwiZW5jb2RlIiwiZm9ybWF0IiwiYXJncyIsImkiLCJyZXBsYWNlIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwidmVyc2lvbiIsImNyZWF0ZU1hcHBlZFJlcXVlc3RPcHRpb25zIiwicmVxdWVzdE9wdGlvbnMiLCJ0aW1lb3V0IiwiZGF0YSIsImluZGV4T2YiLCJjYWNoZWFibGUiLCJDYWxsRW51bSIsIlJlYWQiLCJXcml0ZSIsIkFueSIsIkhvc3RTdGF0dXNFbnVtIiwiVXAiLCJEb3duIiwiVGltZW91dGVkIiwiRVhQSVJBVElPTl9ERUxBWSIsImNyZWF0ZVN0YXRlZnVsSG9zdCIsImhvc3QiLCJzdGF0dXMiLCJsYXN0VXBkYXRlIiwibm93IiwiaXNTdGF0ZWZ1bEhvc3RVcCIsImlzU3RhdGVmdWxIb3N0VGltZW91dGVkIiwiY3JlYXRlU3RhdGVsZXNzSG9zdCIsInByb3RvY29sIiwidXJsIiwiYWNjZXB0IiwiTWV0aG9kRW51bSIsIkRlbGV0ZSIsIkdldCIsIlBvc3QiLCJQdXQiLCJjcmVhdGVSZXRyeWFibGVPcHRpb25zIiwiaG9zdHNDYWNoZSIsInN0YXRlbGVzc0hvc3RzIiwibWFwIiwic3RhdGVsZXNzSG9zdCIsInN0YXRlZnVsSG9zdHMiLCJob3N0c1VwIiwiaG9zdHNUaW1lb3V0ZWQiLCJob3N0c0F2YWlsYWJsZSIsInN0YXRlbGVzc0hvc3RzQXZhaWxhYmxlIiwiZ2V0VGltZW91dCIsInRpbWVvdXRzQ291bnQiLCJiYXNlVGltZW91dCIsInRpbWVvdXRNdWx0aXBsaWVyIiwiaXNOZXR3b3JrRXJyb3IiLCJpc1RpbWVkT3V0IiwiaXNSZXRyeWFibGUiLCJyZXNwb25zZSIsImlzU3VjY2VzcyIsInJldHJ5RGVjaXNpb24iLCJvdXRjb21lcyIsIm9uUmV0cnkiLCJvblN1Y2Nlc3MiLCJvbkZhaWwiLCJyZXRyeWFibGVSZXF1ZXN0IiwidHJhbnNwb3J0ZXIiLCJyZXF1ZXN0Iiwic3RhY2tUcmFjZSIsInNlcmlhbGl6ZURhdGEiLCJzZXJpYWxpemVIZWFkZXJzIiwibWV0aG9kIiwiZGF0YVF1ZXJ5UGFyYW1ldGVycyIsInVzZXJBZ2VudCIsInJldHJ5IiwiaG9zdHMiLCJwb3AiLCJjcmVhdGVSZXRyeUVycm9yIiwic3RhY2tUcmFjZVdpdGhvdXRDcmVkZW50aWFscyIsInBheWxvYWQiLCJzZXJpYWxpemVVcmwiLCJwYXRoIiwiY29ubmVjdFRpbWVvdXQiLCJ0aW1lb3V0cyIsImNvbm5lY3QiLCJyZXNwb25zZVRpbWVvdXQiLCJwdXNoVG9TdGFja1RyYWNlIiwic3RhY2tGcmFtZSIsInRyaWVzTGVmdCIsInB1c2giLCJkZWNpc2lvbnMiLCJkZXNlcmlhbGl6ZVN1Y2Nlc3MiLCJsb2dnZXIiLCJpbmZvIiwic3RhY2tGcmFtZVdpdGhvdXRDcmVkZW50aWFscyIsImRlc2VyaWFsaXplRmFpbHVyZSIsInJlcXVlc3RlciIsInNlbmQiLCJyZXZlcnNlIiwiY3JlYXRlVHJhbnNwb3J0ZXIiLCJyZXF1ZXN0c0NhY2hlIiwicmVzcG9uc2VzQ2FjaGUiLCJyZWFkIiwibWFwcGVkUmVxdWVzdE9wdGlvbnMiLCJjcmVhdGVSZXRyeWFibGVSZXF1ZXN0IiwiZXJyIiwicmVqZWN0IiwiXyIsIndyaXRlIiwiY3JlYXRlVXNlckFnZW50IiwiYWRkIiwiYWRkZWRVc2VyQWdlbnQiLCJzZWdtZW50IiwiY29udGVudCIsImUiLCJjcmVhdGVEZXNlcmlhbGl6YXRpb25FcnJvciIsIm1lc3NhZ2UiLCJjcmVhdGVBcGlFcnJvciIsInF1ZXJ5UGFyYW1ldGVyc0FzU3RyaW5nIiwic2VyaWFsaXplUXVlcnlQYXJhbWV0ZXJzIiwiY2hhckF0Iiwic3Vic3RyIiwicGFyYW1ldGVycyIsImlzT2JqZWN0T3JBcnJheSIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiY2FsbCIsImpvaW4iLCJBcnJheSIsImlzQXJyYXkiLCJzZXJpYWxpemVkSGVhZGVycyIsImhlYWRlciIsInRvTG93ZXJDYXNlIiwibW9kaWZpZWRIZWFkZXJzIiwidHJhbnNwb3J0ZXJTdGFja1RyYWNlIiwibmFtZSIsImNyZWF0ZVNlYXJjaENsaWVudCIsImF1dGgiLCJjb25jYXQiLCJhZGRBbGdvbGlhQWdlbnQiLCJjbGVhckNhY2hlIiwiY3VzdG9tUmVxdWVzdCIsImluaXRJbmRleCIsImluZGV4TmFtZSIsInNlYXJjaEluZGV4IiwibXVsdGlwbGVRdWVyaWVzIiwicXVlcmllcyIsInJlcXVlc3RzIiwicXVlcnkiLCJwYXJhbXMiLCJtdWx0aXBsZVNlYXJjaEZvckZhY2V0VmFsdWVzIiwiZmFjZXROYW1lIiwiZmFjZXRRdWVyeSIsInNlYXJjaEZvckZhY2V0VmFsdWVzIiwiZmluZEFuc3dlcnMiLCJxdWVyeUxhbmd1YWdlcyIsInNlYXJjaCIsIkxvZ0xldmVsRW51bSIsIkRlYnVnIiwiSW5mbyIsIkVycm9yIiwiY3JlYXRlQ29uc29sZUxvZ2dlciIsImxvZ0xldmVsIiwiZGVidWciLCJjb25zb2xlIiwiZXJyb3IiLCJjcmVhdGVCcm93c2VyWGhyUmVxdWVzdGVyIiwiYmFzZVJlcXVlc3RlciIsIlhNTEh0dHBSZXF1ZXN0Iiwib3BlbiIsInNldFJlcXVlc3RIZWFkZXIiLCJjcmVhdGVUaW1lb3V0Iiwic2V0VGltZW91dCIsImFib3J0Iiwib25yZWFkeXN0YXRlY2hhbmdlIiwicmVhZHlTdGF0ZSIsIk9QRU5FRCIsImNsZWFyVGltZW91dCIsIm9uZXJyb3IiLCJyZXNwb25zZVRleHQiLCJvbmxvYWQiLCJhbGdvbGlhc2VhcmNoIiwiY29tbW9uT3B0aW9ucyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/algoliasearch@4.22.1/node_modules/algoliasearch/dist/algoliasearch-lite.esm.browser.js\n");

/***/ })

};
;