"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/fuse.js@6.6.2";
exports.ids = ["vendor-chunks/fuse.js@6.6.2"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/fuse.js@6.6.2/node_modules/fuse.js/dist/fuse.esm.js":
/*!********************************************************************************!*\
  !*** ./node_modules/.pnpm/fuse.js@6.6.2/node_modules/fuse.js/dist/fuse.esm.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Fuse)\n/* harmony export */ });\n/**\n * Fuse.js v6.6.2 - Lightweight fuzzy-search (http://fusejs.io)\n *\n * Copyright (c) 2022 Kiro Risk (http://kiro.me)\n * All Rights Reserved. Apache Software License 2.0\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n */ function isArray(value) {\n    return !Array.isArray ? getTag(value) === \"[object Array]\" : Array.isArray(value);\n}\n// Adapted from: https://github.com/lodash/lodash/blob/master/.internal/baseToString.js\nconst INFINITY = 1 / 0;\nfunction baseToString(value) {\n    // Exit early for strings to avoid a performance hit in some environments.\n    if (typeof value == \"string\") {\n        return value;\n    }\n    let result = value + \"\";\n    return result == \"0\" && 1 / value == -INFINITY ? \"-0\" : result;\n}\nfunction toString(value) {\n    return value == null ? \"\" : baseToString(value);\n}\nfunction isString(value) {\n    return typeof value === \"string\";\n}\nfunction isNumber(value) {\n    return typeof value === \"number\";\n}\n// Adapted from: https://github.com/lodash/lodash/blob/master/isBoolean.js\nfunction isBoolean(value) {\n    return value === true || value === false || isObjectLike(value) && getTag(value) == \"[object Boolean]\";\n}\nfunction isObject(value) {\n    return typeof value === \"object\";\n}\n// Checks if `value` is object-like.\nfunction isObjectLike(value) {\n    return isObject(value) && value !== null;\n}\nfunction isDefined(value) {\n    return value !== undefined && value !== null;\n}\nfunction isBlank(value) {\n    return !value.trim().length;\n}\n// Gets the `toStringTag` of `value`.\n// Adapted from: https://github.com/lodash/lodash/blob/master/.internal/getTag.js\nfunction getTag(value) {\n    return value == null ? value === undefined ? \"[object Undefined]\" : \"[object Null]\" : Object.prototype.toString.call(value);\n}\nconst EXTENDED_SEARCH_UNAVAILABLE = \"Extended search is not available\";\nconst INCORRECT_INDEX_TYPE = \"Incorrect 'index' type\";\nconst LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = (key)=>`Invalid value for key ${key}`;\nconst PATTERN_LENGTH_TOO_LARGE = (max)=>`Pattern length exceeds max of ${max}.`;\nconst MISSING_KEY_PROPERTY = (name)=>`Missing ${name} property in key`;\nconst INVALID_KEY_WEIGHT_VALUE = (key)=>`Property 'weight' in key '${key}' must be a positive integer`;\nconst hasOwn = Object.prototype.hasOwnProperty;\nclass KeyStore {\n    constructor(keys){\n        this._keys = [];\n        this._keyMap = {};\n        let totalWeight = 0;\n        keys.forEach((key)=>{\n            let obj = createKey(key);\n            totalWeight += obj.weight;\n            this._keys.push(obj);\n            this._keyMap[obj.id] = obj;\n            totalWeight += obj.weight;\n        });\n        // Normalize weights so that their sum is equal to 1\n        this._keys.forEach((key)=>{\n            key.weight /= totalWeight;\n        });\n    }\n    get(keyId) {\n        return this._keyMap[keyId];\n    }\n    keys() {\n        return this._keys;\n    }\n    toJSON() {\n        return JSON.stringify(this._keys);\n    }\n}\nfunction createKey(key) {\n    let path = null;\n    let id = null;\n    let src = null;\n    let weight = 1;\n    let getFn = null;\n    if (isString(key) || isArray(key)) {\n        src = key;\n        path = createKeyPath(key);\n        id = createKeyId(key);\n    } else {\n        if (!hasOwn.call(key, \"name\")) {\n            throw new Error(MISSING_KEY_PROPERTY(\"name\"));\n        }\n        const name = key.name;\n        src = name;\n        if (hasOwn.call(key, \"weight\")) {\n            weight = key.weight;\n            if (weight <= 0) {\n                throw new Error(INVALID_KEY_WEIGHT_VALUE(name));\n            }\n        }\n        path = createKeyPath(name);\n        id = createKeyId(name);\n        getFn = key.getFn;\n    }\n    return {\n        path,\n        id,\n        weight,\n        src,\n        getFn\n    };\n}\nfunction createKeyPath(key) {\n    return isArray(key) ? key : key.split(\".\");\n}\nfunction createKeyId(key) {\n    return isArray(key) ? key.join(\".\") : key;\n}\nfunction get(obj, path) {\n    let list = [];\n    let arr = false;\n    const deepGet = (obj, path, index)=>{\n        if (!isDefined(obj)) {\n            return;\n        }\n        if (!path[index]) {\n            // If there's no path left, we've arrived at the object we care about.\n            list.push(obj);\n        } else {\n            let key = path[index];\n            const value = obj[key];\n            if (!isDefined(value)) {\n                return;\n            }\n            // If we're at the last value in the path, and if it's a string/number/bool,\n            // add it to the list\n            if (index === path.length - 1 && (isString(value) || isNumber(value) || isBoolean(value))) {\n                list.push(toString(value));\n            } else if (isArray(value)) {\n                arr = true;\n                // Search each item in the array.\n                for(let i = 0, len = value.length; i < len; i += 1){\n                    deepGet(value[i], path, index + 1);\n                }\n            } else if (path.length) {\n                // An object. Recurse further.\n                deepGet(value, path, index + 1);\n            }\n        }\n    };\n    // Backwards compatibility (since path used to be a string)\n    deepGet(obj, isString(path) ? path.split(\".\") : path, 0);\n    return arr ? list : list[0];\n}\nconst MatchOptions = {\n    // Whether the matches should be included in the result set. When `true`, each record in the result\n    // set will include the indices of the matched characters.\n    // These can consequently be used for highlighting purposes.\n    includeMatches: false,\n    // When `true`, the matching function will continue to the end of a search pattern even if\n    // a perfect match has already been located in the string.\n    findAllMatches: false,\n    // Minimum number of characters that must be matched before a result is considered a match\n    minMatchCharLength: 1\n};\nconst BasicOptions = {\n    // When `true`, the algorithm continues searching to the end of the input even if a perfect\n    // match is found before the end of the same input.\n    isCaseSensitive: false,\n    // When true, the matching function will continue to the end of a search pattern even if\n    includeScore: false,\n    // List of properties that will be searched. This also supports nested properties.\n    keys: [],\n    // Whether to sort the result list, by score\n    shouldSort: true,\n    // Default sort function: sort by ascending score, ascending index\n    sortFn: (a, b)=>a.score === b.score ? a.idx < b.idx ? -1 : 1 : a.score < b.score ? -1 : 1\n};\nconst FuzzyOptions = {\n    // Approximately where in the text is the pattern expected to be found?\n    location: 0,\n    // At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match\n    // (of both letters and location), a threshold of '1.0' would match anything.\n    threshold: 0.6,\n    // Determines how close the match must be to the fuzzy location (specified above).\n    // An exact letter match which is 'distance' characters away from the fuzzy location\n    // would score as a complete mismatch. A distance of '0' requires the match be at\n    // the exact location specified, a threshold of '1000' would require a perfect match\n    // to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.\n    distance: 100\n};\nconst AdvancedOptions = {\n    // When `true`, it enables the use of unix-like search commands\n    useExtendedSearch: false,\n    // The get function to use when fetching an object's properties.\n    // The default will search nested paths *ie foo.bar.baz*\n    getFn: get,\n    // When `true`, search will ignore `location` and `distance`, so it won't matter\n    // where in the string the pattern appears.\n    // More info: https://fusejs.io/concepts/scoring-theory.html#fuzziness-score\n    ignoreLocation: false,\n    // When `true`, the calculation for the relevance score (used for sorting) will\n    // ignore the field-length norm.\n    // More info: https://fusejs.io/concepts/scoring-theory.html#field-length-norm\n    ignoreFieldNorm: false,\n    // The weight to determine how much field length norm effects scoring.\n    fieldNormWeight: 1\n};\nvar Config = {\n    ...BasicOptions,\n    ...MatchOptions,\n    ...FuzzyOptions,\n    ...AdvancedOptions\n};\nconst SPACE = /[^ ]+/g;\n// Field-length norm: the shorter the field, the higher the weight.\n// Set to 3 decimals to reduce index size.\nfunction norm(weight = 1, mantissa = 3) {\n    const cache = new Map();\n    const m = Math.pow(10, mantissa);\n    return {\n        get (value) {\n            const numTokens = value.match(SPACE).length;\n            if (cache.has(numTokens)) {\n                return cache.get(numTokens);\n            }\n            // Default function is 1/sqrt(x), weight makes that variable\n            const norm = 1 / Math.pow(numTokens, 0.5 * weight);\n            // In place of `toFixed(mantissa)`, for faster computation\n            const n = parseFloat(Math.round(norm * m) / m);\n            cache.set(numTokens, n);\n            return n;\n        },\n        clear () {\n            cache.clear();\n        }\n    };\n}\nclass FuseIndex {\n    constructor({ getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}){\n        this.norm = norm(fieldNormWeight, 3);\n        this.getFn = getFn;\n        this.isCreated = false;\n        this.setIndexRecords();\n    }\n    setSources(docs = []) {\n        this.docs = docs;\n    }\n    setIndexRecords(records = []) {\n        this.records = records;\n    }\n    setKeys(keys = []) {\n        this.keys = keys;\n        this._keysMap = {};\n        keys.forEach((key, idx)=>{\n            this._keysMap[key.id] = idx;\n        });\n    }\n    create() {\n        if (this.isCreated || !this.docs.length) {\n            return;\n        }\n        this.isCreated = true;\n        // List is Array<String>\n        if (isString(this.docs[0])) {\n            this.docs.forEach((doc, docIndex)=>{\n                this._addString(doc, docIndex);\n            });\n        } else {\n            // List is Array<Object>\n            this.docs.forEach((doc, docIndex)=>{\n                this._addObject(doc, docIndex);\n            });\n        }\n        this.norm.clear();\n    }\n    // Adds a doc to the end of the index\n    add(doc) {\n        const idx = this.size();\n        if (isString(doc)) {\n            this._addString(doc, idx);\n        } else {\n            this._addObject(doc, idx);\n        }\n    }\n    // Removes the doc at the specified index of the index\n    removeAt(idx) {\n        this.records.splice(idx, 1);\n        // Change ref index of every subsquent doc\n        for(let i = idx, len = this.size(); i < len; i += 1){\n            this.records[i].i -= 1;\n        }\n    }\n    getValueForItemAtKeyId(item, keyId) {\n        return item[this._keysMap[keyId]];\n    }\n    size() {\n        return this.records.length;\n    }\n    _addString(doc, docIndex) {\n        if (!isDefined(doc) || isBlank(doc)) {\n            return;\n        }\n        let record = {\n            v: doc,\n            i: docIndex,\n            n: this.norm.get(doc)\n        };\n        this.records.push(record);\n    }\n    _addObject(doc, docIndex) {\n        let record = {\n            i: docIndex,\n            $: {}\n        };\n        // Iterate over every key (i.e, path), and fetch the value at that key\n        this.keys.forEach((key, keyIndex)=>{\n            let value = key.getFn ? key.getFn(doc) : this.getFn(doc, key.path);\n            if (!isDefined(value)) {\n                return;\n            }\n            if (isArray(value)) {\n                let subRecords = [];\n                const stack = [\n                    {\n                        nestedArrIndex: -1,\n                        value\n                    }\n                ];\n                while(stack.length){\n                    const { nestedArrIndex, value } = stack.pop();\n                    if (!isDefined(value)) {\n                        continue;\n                    }\n                    if (isString(value) && !isBlank(value)) {\n                        let subRecord = {\n                            v: value,\n                            i: nestedArrIndex,\n                            n: this.norm.get(value)\n                        };\n                        subRecords.push(subRecord);\n                    } else if (isArray(value)) {\n                        value.forEach((item, k)=>{\n                            stack.push({\n                                nestedArrIndex: k,\n                                value: item\n                            });\n                        });\n                    } else ;\n                }\n                record.$[keyIndex] = subRecords;\n            } else if (isString(value) && !isBlank(value)) {\n                let subRecord = {\n                    v: value,\n                    n: this.norm.get(value)\n                };\n                record.$[keyIndex] = subRecord;\n            }\n        });\n        this.records.push(record);\n    }\n    toJSON() {\n        return {\n            keys: this.keys,\n            records: this.records\n        };\n    }\n}\nfunction createIndex(keys, docs, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {\n    const myIndex = new FuseIndex({\n        getFn,\n        fieldNormWeight\n    });\n    myIndex.setKeys(keys.map(createKey));\n    myIndex.setSources(docs);\n    myIndex.create();\n    return myIndex;\n}\nfunction parseIndex(data, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {\n    const { keys, records } = data;\n    const myIndex = new FuseIndex({\n        getFn,\n        fieldNormWeight\n    });\n    myIndex.setKeys(keys);\n    myIndex.setIndexRecords(records);\n    return myIndex;\n}\nfunction computeScore$1(pattern, { errors = 0, currentLocation = 0, expectedLocation = 0, distance = Config.distance, ignoreLocation = Config.ignoreLocation } = {}) {\n    const accuracy = errors / pattern.length;\n    if (ignoreLocation) {\n        return accuracy;\n    }\n    const proximity = Math.abs(expectedLocation - currentLocation);\n    if (!distance) {\n        // Dodge divide by zero error.\n        return proximity ? 1.0 : accuracy;\n    }\n    return accuracy + proximity / distance;\n}\nfunction convertMaskToIndices(matchmask = [], minMatchCharLength = Config.minMatchCharLength) {\n    let indices = [];\n    let start = -1;\n    let end = -1;\n    let i = 0;\n    for(let len = matchmask.length; i < len; i += 1){\n        let match = matchmask[i];\n        if (match && start === -1) {\n            start = i;\n        } else if (!match && start !== -1) {\n            end = i - 1;\n            if (end - start + 1 >= minMatchCharLength) {\n                indices.push([\n                    start,\n                    end\n                ]);\n            }\n            start = -1;\n        }\n    }\n    // (i-1 - start) + 1 => i - start\n    if (matchmask[i - 1] && i - start >= minMatchCharLength) {\n        indices.push([\n            start,\n            i - 1\n        ]);\n    }\n    return indices;\n}\n// Machine word size\nconst MAX_BITS = 32;\nfunction search(text, pattern, patternAlphabet, { location = Config.location, distance = Config.distance, threshold = Config.threshold, findAllMatches = Config.findAllMatches, minMatchCharLength = Config.minMatchCharLength, includeMatches = Config.includeMatches, ignoreLocation = Config.ignoreLocation } = {}) {\n    if (pattern.length > MAX_BITS) {\n        throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS));\n    }\n    const patternLen = pattern.length;\n    // Set starting location at beginning text and initialize the alphabet.\n    const textLen = text.length;\n    // Handle the case when location > text.length\n    const expectedLocation = Math.max(0, Math.min(location, textLen));\n    // Highest score beyond which we give up.\n    let currentThreshold = threshold;\n    // Is there a nearby exact match? (speedup)\n    let bestLocation = expectedLocation;\n    // Performance: only computer matches when the minMatchCharLength > 1\n    // OR if `includeMatches` is true.\n    const computeMatches = minMatchCharLength > 1 || includeMatches;\n    // A mask of the matches, used for building the indices\n    const matchMask = computeMatches ? Array(textLen) : [];\n    let index;\n    // Get all exact matches, here for speed up\n    while((index = text.indexOf(pattern, bestLocation)) > -1){\n        let score = computeScore$1(pattern, {\n            currentLocation: index,\n            expectedLocation,\n            distance,\n            ignoreLocation\n        });\n        currentThreshold = Math.min(score, currentThreshold);\n        bestLocation = index + patternLen;\n        if (computeMatches) {\n            let i = 0;\n            while(i < patternLen){\n                matchMask[index + i] = 1;\n                i += 1;\n            }\n        }\n    }\n    // Reset the best location\n    bestLocation = -1;\n    let lastBitArr = [];\n    let finalScore = 1;\n    let binMax = patternLen + textLen;\n    const mask = 1 << patternLen - 1;\n    for(let i = 0; i < patternLen; i += 1){\n        // Scan for the best match; each iteration allows for one more error.\n        // Run a binary search to determine how far from the match location we can stray\n        // at this error level.\n        let binMin = 0;\n        let binMid = binMax;\n        while(binMin < binMid){\n            const score = computeScore$1(pattern, {\n                errors: i,\n                currentLocation: expectedLocation + binMid,\n                expectedLocation,\n                distance,\n                ignoreLocation\n            });\n            if (score <= currentThreshold) {\n                binMin = binMid;\n            } else {\n                binMax = binMid;\n            }\n            binMid = Math.floor((binMax - binMin) / 2 + binMin);\n        }\n        // Use the result from this iteration as the maximum for the next.\n        binMax = binMid;\n        let start = Math.max(1, expectedLocation - binMid + 1);\n        let finish = findAllMatches ? textLen : Math.min(expectedLocation + binMid, textLen) + patternLen;\n        // Initialize the bit array\n        let bitArr = Array(finish + 2);\n        bitArr[finish + 1] = (1 << i) - 1;\n        for(let j = finish; j >= start; j -= 1){\n            let currentLocation = j - 1;\n            let charMatch = patternAlphabet[text.charAt(currentLocation)];\n            if (computeMatches) {\n                // Speed up: quick bool to int conversion (i.e, `charMatch ? 1 : 0`)\n                matchMask[currentLocation] = +!!charMatch;\n            }\n            // First pass: exact match\n            bitArr[j] = (bitArr[j + 1] << 1 | 1) & charMatch;\n            // Subsequent passes: fuzzy match\n            if (i) {\n                bitArr[j] |= (lastBitArr[j + 1] | lastBitArr[j]) << 1 | 1 | lastBitArr[j + 1];\n            }\n            if (bitArr[j] & mask) {\n                finalScore = computeScore$1(pattern, {\n                    errors: i,\n                    currentLocation,\n                    expectedLocation,\n                    distance,\n                    ignoreLocation\n                });\n                // This match will almost certainly be better than any existing match.\n                // But check anyway.\n                if (finalScore <= currentThreshold) {\n                    // Indeed it is\n                    currentThreshold = finalScore;\n                    bestLocation = currentLocation;\n                    // Already passed `loc`, downhill from here on in.\n                    if (bestLocation <= expectedLocation) {\n                        break;\n                    }\n                    // When passing `bestLocation`, don't exceed our current distance from `expectedLocation`.\n                    start = Math.max(1, 2 * expectedLocation - bestLocation);\n                }\n            }\n        }\n        // No hope for a (better) match at greater error levels.\n        const score = computeScore$1(pattern, {\n            errors: i + 1,\n            currentLocation: expectedLocation,\n            expectedLocation,\n            distance,\n            ignoreLocation\n        });\n        if (score > currentThreshold) {\n            break;\n        }\n        lastBitArr = bitArr;\n    }\n    const result = {\n        isMatch: bestLocation >= 0,\n        // Count exact matches (those with a score of 0) to be \"almost\" exact\n        score: Math.max(0.001, finalScore)\n    };\n    if (computeMatches) {\n        const indices = convertMaskToIndices(matchMask, minMatchCharLength);\n        if (!indices.length) {\n            result.isMatch = false;\n        } else if (includeMatches) {\n            result.indices = indices;\n        }\n    }\n    return result;\n}\nfunction createPatternAlphabet(pattern) {\n    let mask = {};\n    for(let i = 0, len = pattern.length; i < len; i += 1){\n        const char = pattern.charAt(i);\n        mask[char] = (mask[char] || 0) | 1 << len - i - 1;\n    }\n    return mask;\n}\nclass BitapSearch {\n    constructor(pattern, { location = Config.location, threshold = Config.threshold, distance = Config.distance, includeMatches = Config.includeMatches, findAllMatches = Config.findAllMatches, minMatchCharLength = Config.minMatchCharLength, isCaseSensitive = Config.isCaseSensitive, ignoreLocation = Config.ignoreLocation } = {}){\n        this.options = {\n            location,\n            threshold,\n            distance,\n            includeMatches,\n            findAllMatches,\n            minMatchCharLength,\n            isCaseSensitive,\n            ignoreLocation\n        };\n        this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();\n        this.chunks = [];\n        if (!this.pattern.length) {\n            return;\n        }\n        const addChunk = (pattern, startIndex)=>{\n            this.chunks.push({\n                pattern,\n                alphabet: createPatternAlphabet(pattern),\n                startIndex\n            });\n        };\n        const len = this.pattern.length;\n        if (len > MAX_BITS) {\n            let i = 0;\n            const remainder = len % MAX_BITS;\n            const end = len - remainder;\n            while(i < end){\n                addChunk(this.pattern.substr(i, MAX_BITS), i);\n                i += MAX_BITS;\n            }\n            if (remainder) {\n                const startIndex = len - MAX_BITS;\n                addChunk(this.pattern.substr(startIndex), startIndex);\n            }\n        } else {\n            addChunk(this.pattern, 0);\n        }\n    }\n    searchIn(text) {\n        const { isCaseSensitive, includeMatches } = this.options;\n        if (!isCaseSensitive) {\n            text = text.toLowerCase();\n        }\n        // Exact match\n        if (this.pattern === text) {\n            let result = {\n                isMatch: true,\n                score: 0\n            };\n            if (includeMatches) {\n                result.indices = [\n                    [\n                        0,\n                        text.length - 1\n                    ]\n                ];\n            }\n            return result;\n        }\n        // Otherwise, use Bitap algorithm\n        const { location, distance, threshold, findAllMatches, minMatchCharLength, ignoreLocation } = this.options;\n        let allIndices = [];\n        let totalScore = 0;\n        let hasMatches = false;\n        this.chunks.forEach(({ pattern, alphabet, startIndex })=>{\n            const { isMatch, score, indices } = search(text, pattern, alphabet, {\n                location: location + startIndex,\n                distance,\n                threshold,\n                findAllMatches,\n                minMatchCharLength,\n                includeMatches,\n                ignoreLocation\n            });\n            if (isMatch) {\n                hasMatches = true;\n            }\n            totalScore += score;\n            if (isMatch && indices) {\n                allIndices = [\n                    ...allIndices,\n                    ...indices\n                ];\n            }\n        });\n        let result = {\n            isMatch: hasMatches,\n            score: hasMatches ? totalScore / this.chunks.length : 1\n        };\n        if (hasMatches && includeMatches) {\n            result.indices = allIndices;\n        }\n        return result;\n    }\n}\nclass BaseMatch {\n    constructor(pattern){\n        this.pattern = pattern;\n    }\n    static isMultiMatch(pattern) {\n        return getMatch(pattern, this.multiRegex);\n    }\n    static isSingleMatch(pattern) {\n        return getMatch(pattern, this.singleRegex);\n    }\n    search() {}\n}\nfunction getMatch(pattern, exp) {\n    const matches = pattern.match(exp);\n    return matches ? matches[1] : null;\n}\n// Token: 'file\nclass ExactMatch extends BaseMatch {\n    constructor(pattern){\n        super(pattern);\n    }\n    static get type() {\n        return \"exact\";\n    }\n    static get multiRegex() {\n        return /^=\"(.*)\"$/;\n    }\n    static get singleRegex() {\n        return /^=(.*)$/;\n    }\n    search(text) {\n        const isMatch = text === this.pattern;\n        return {\n            isMatch,\n            score: isMatch ? 0 : 1,\n            indices: [\n                0,\n                this.pattern.length - 1\n            ]\n        };\n    }\n}\n// Token: !fire\nclass InverseExactMatch extends BaseMatch {\n    constructor(pattern){\n        super(pattern);\n    }\n    static get type() {\n        return \"inverse-exact\";\n    }\n    static get multiRegex() {\n        return /^!\"(.*)\"$/;\n    }\n    static get singleRegex() {\n        return /^!(.*)$/;\n    }\n    search(text) {\n        const index = text.indexOf(this.pattern);\n        const isMatch = index === -1;\n        return {\n            isMatch,\n            score: isMatch ? 0 : 1,\n            indices: [\n                0,\n                text.length - 1\n            ]\n        };\n    }\n}\n// Token: ^file\nclass PrefixExactMatch extends BaseMatch {\n    constructor(pattern){\n        super(pattern);\n    }\n    static get type() {\n        return \"prefix-exact\";\n    }\n    static get multiRegex() {\n        return /^\\^\"(.*)\"$/;\n    }\n    static get singleRegex() {\n        return /^\\^(.*)$/;\n    }\n    search(text) {\n        const isMatch = text.startsWith(this.pattern);\n        return {\n            isMatch,\n            score: isMatch ? 0 : 1,\n            indices: [\n                0,\n                this.pattern.length - 1\n            ]\n        };\n    }\n}\n// Token: !^fire\nclass InversePrefixExactMatch extends BaseMatch {\n    constructor(pattern){\n        super(pattern);\n    }\n    static get type() {\n        return \"inverse-prefix-exact\";\n    }\n    static get multiRegex() {\n        return /^!\\^\"(.*)\"$/;\n    }\n    static get singleRegex() {\n        return /^!\\^(.*)$/;\n    }\n    search(text) {\n        const isMatch = !text.startsWith(this.pattern);\n        return {\n            isMatch,\n            score: isMatch ? 0 : 1,\n            indices: [\n                0,\n                text.length - 1\n            ]\n        };\n    }\n}\n// Token: .file$\nclass SuffixExactMatch extends BaseMatch {\n    constructor(pattern){\n        super(pattern);\n    }\n    static get type() {\n        return \"suffix-exact\";\n    }\n    static get multiRegex() {\n        return /^\"(.*)\"\\$$/;\n    }\n    static get singleRegex() {\n        return /^(.*)\\$$/;\n    }\n    search(text) {\n        const isMatch = text.endsWith(this.pattern);\n        return {\n            isMatch,\n            score: isMatch ? 0 : 1,\n            indices: [\n                text.length - this.pattern.length,\n                text.length - 1\n            ]\n        };\n    }\n}\n// Token: !.file$\nclass InverseSuffixExactMatch extends BaseMatch {\n    constructor(pattern){\n        super(pattern);\n    }\n    static get type() {\n        return \"inverse-suffix-exact\";\n    }\n    static get multiRegex() {\n        return /^!\"(.*)\"\\$$/;\n    }\n    static get singleRegex() {\n        return /^!(.*)\\$$/;\n    }\n    search(text) {\n        const isMatch = !text.endsWith(this.pattern);\n        return {\n            isMatch,\n            score: isMatch ? 0 : 1,\n            indices: [\n                0,\n                text.length - 1\n            ]\n        };\n    }\n}\nclass FuzzyMatch extends BaseMatch {\n    constructor(pattern, { location = Config.location, threshold = Config.threshold, distance = Config.distance, includeMatches = Config.includeMatches, findAllMatches = Config.findAllMatches, minMatchCharLength = Config.minMatchCharLength, isCaseSensitive = Config.isCaseSensitive, ignoreLocation = Config.ignoreLocation } = {}){\n        super(pattern);\n        this._bitapSearch = new BitapSearch(pattern, {\n            location,\n            threshold,\n            distance,\n            includeMatches,\n            findAllMatches,\n            minMatchCharLength,\n            isCaseSensitive,\n            ignoreLocation\n        });\n    }\n    static get type() {\n        return \"fuzzy\";\n    }\n    static get multiRegex() {\n        return /^\"(.*)\"$/;\n    }\n    static get singleRegex() {\n        return /^(.*)$/;\n    }\n    search(text) {\n        return this._bitapSearch.searchIn(text);\n    }\n}\n// Token: 'file\nclass IncludeMatch extends BaseMatch {\n    constructor(pattern){\n        super(pattern);\n    }\n    static get type() {\n        return \"include\";\n    }\n    static get multiRegex() {\n        return /^'\"(.*)\"$/;\n    }\n    static get singleRegex() {\n        return /^'(.*)$/;\n    }\n    search(text) {\n        let location = 0;\n        let index;\n        const indices = [];\n        const patternLen = this.pattern.length;\n        // Get all exact matches\n        while((index = text.indexOf(this.pattern, location)) > -1){\n            location = index + patternLen;\n            indices.push([\n                index,\n                location - 1\n            ]);\n        }\n        const isMatch = !!indices.length;\n        return {\n            isMatch,\n            score: isMatch ? 0 : 1,\n            indices\n        };\n    }\n}\n// â—Order is important. DO NOT CHANGE.\nconst searchers = [\n    ExactMatch,\n    IncludeMatch,\n    PrefixExactMatch,\n    InversePrefixExactMatch,\n    InverseSuffixExactMatch,\n    SuffixExactMatch,\n    InverseExactMatch,\n    FuzzyMatch\n];\nconst searchersLen = searchers.length;\n// Regex to split by spaces, but keep anything in quotes together\nconst SPACE_RE = / +(?=(?:[^\\\"]*\\\"[^\\\"]*\\\")*[^\\\"]*$)/;\nconst OR_TOKEN = \"|\";\n// Return a 2D array representation of the query, for simpler parsing.\n// Example:\n// \"^core go$ | rb$ | py$ xy$\" => [[\"^core\", \"go$\"], [\"rb$\"], [\"py$\", \"xy$\"]]\nfunction parseQuery(pattern, options = {}) {\n    return pattern.split(OR_TOKEN).map((item)=>{\n        let query = item.trim().split(SPACE_RE).filter((item)=>item && !!item.trim());\n        let results = [];\n        for(let i = 0, len = query.length; i < len; i += 1){\n            const queryItem = query[i];\n            // 1. Handle multiple query match (i.e, once that are quoted, like `\"hello world\"`)\n            let found = false;\n            let idx = -1;\n            while(!found && ++idx < searchersLen){\n                const searcher = searchers[idx];\n                let token = searcher.isMultiMatch(queryItem);\n                if (token) {\n                    results.push(new searcher(token, options));\n                    found = true;\n                }\n            }\n            if (found) {\n                continue;\n            }\n            // 2. Handle single query matches (i.e, once that are *not* quoted)\n            idx = -1;\n            while(++idx < searchersLen){\n                const searcher = searchers[idx];\n                let token = searcher.isSingleMatch(queryItem);\n                if (token) {\n                    results.push(new searcher(token, options));\n                    break;\n                }\n            }\n        }\n        return results;\n    });\n}\n// These extended matchers can return an array of matches, as opposed\n// to a singl match\nconst MultiMatchSet = new Set([\n    FuzzyMatch.type,\n    IncludeMatch.type\n]);\n/**\n * Command-like searching\n * ======================\n *\n * Given multiple search terms delimited by spaces.e.g. `^jscript .python$ ruby !java`,\n * search in a given text.\n *\n * Search syntax:\n *\n * | Token       | Match type                 | Description                            |\n * | ----------- | -------------------------- | -------------------------------------- |\n * | `jscript`   | fuzzy-match                | Items that fuzzy match `jscript`       |\n * | `=scheme`   | exact-match                | Items that are `scheme`                |\n * | `'python`   | include-match              | Items that include `python`            |\n * | `!ruby`     | inverse-exact-match        | Items that do not include `ruby`       |\n * | `^java`     | prefix-exact-match         | Items that start with `java`           |\n * | `!^earlang` | inverse-prefix-exact-match | Items that do not start with `earlang` |\n * | `.js$`      | suffix-exact-match         | Items that end with `.js`              |\n * | `!.go$`     | inverse-suffix-exact-match | Items that do not end with `.go`       |\n *\n * A single pipe character acts as an OR operator. For example, the following\n * query matches entries that start with `core` and end with either`go`, `rb`,\n * or`py`.\n *\n * ```\n * ^core go$ | rb$ | py$\n * ```\n */ class ExtendedSearch {\n    constructor(pattern, { isCaseSensitive = Config.isCaseSensitive, includeMatches = Config.includeMatches, minMatchCharLength = Config.minMatchCharLength, ignoreLocation = Config.ignoreLocation, findAllMatches = Config.findAllMatches, location = Config.location, threshold = Config.threshold, distance = Config.distance } = {}){\n        this.query = null;\n        this.options = {\n            isCaseSensitive,\n            includeMatches,\n            minMatchCharLength,\n            findAllMatches,\n            ignoreLocation,\n            location,\n            threshold,\n            distance\n        };\n        this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();\n        this.query = parseQuery(this.pattern, this.options);\n    }\n    static condition(_, options) {\n        return options.useExtendedSearch;\n    }\n    searchIn(text) {\n        const query = this.query;\n        if (!query) {\n            return {\n                isMatch: false,\n                score: 1\n            };\n        }\n        const { includeMatches, isCaseSensitive } = this.options;\n        text = isCaseSensitive ? text : text.toLowerCase();\n        let numMatches = 0;\n        let allIndices = [];\n        let totalScore = 0;\n        // ORs\n        for(let i = 0, qLen = query.length; i < qLen; i += 1){\n            const searchers = query[i];\n            // Reset indices\n            allIndices.length = 0;\n            numMatches = 0;\n            // ANDs\n            for(let j = 0, pLen = searchers.length; j < pLen; j += 1){\n                const searcher = searchers[j];\n                const { isMatch, indices, score } = searcher.search(text);\n                if (isMatch) {\n                    numMatches += 1;\n                    totalScore += score;\n                    if (includeMatches) {\n                        const type = searcher.constructor.type;\n                        if (MultiMatchSet.has(type)) {\n                            allIndices = [\n                                ...allIndices,\n                                ...indices\n                            ];\n                        } else {\n                            allIndices.push(indices);\n                        }\n                    }\n                } else {\n                    totalScore = 0;\n                    numMatches = 0;\n                    allIndices.length = 0;\n                    break;\n                }\n            }\n            // OR condition, so if TRUE, return\n            if (numMatches) {\n                let result = {\n                    isMatch: true,\n                    score: totalScore / numMatches\n                };\n                if (includeMatches) {\n                    result.indices = allIndices;\n                }\n                return result;\n            }\n        }\n        // Nothing was matched\n        return {\n            isMatch: false,\n            score: 1\n        };\n    }\n}\nconst registeredSearchers = [];\nfunction register(...args) {\n    registeredSearchers.push(...args);\n}\nfunction createSearcher(pattern, options) {\n    for(let i = 0, len = registeredSearchers.length; i < len; i += 1){\n        let searcherClass = registeredSearchers[i];\n        if (searcherClass.condition(pattern, options)) {\n            return new searcherClass(pattern, options);\n        }\n    }\n    return new BitapSearch(pattern, options);\n}\nconst LogicalOperator = {\n    AND: \"$and\",\n    OR: \"$or\"\n};\nconst KeyType = {\n    PATH: \"$path\",\n    PATTERN: \"$val\"\n};\nconst isExpression = (query)=>!!(query[LogicalOperator.AND] || query[LogicalOperator.OR]);\nconst isPath = (query)=>!!query[KeyType.PATH];\nconst isLeaf = (query)=>!isArray(query) && isObject(query) && !isExpression(query);\nconst convertToExplicit = (query)=>({\n        [LogicalOperator.AND]: Object.keys(query).map((key)=>({\n                [key]: query[key]\n            }))\n    });\n// When `auto` is `true`, the parse function will infer and initialize and add\n// the appropriate `Searcher` instance\nfunction parse(query, options, { auto = true } = {}) {\n    const next = (query)=>{\n        let keys = Object.keys(query);\n        const isQueryPath = isPath(query);\n        if (!isQueryPath && keys.length > 1 && !isExpression(query)) {\n            return next(convertToExplicit(query));\n        }\n        if (isLeaf(query)) {\n            const key = isQueryPath ? query[KeyType.PATH] : keys[0];\n            const pattern = isQueryPath ? query[KeyType.PATTERN] : query[key];\n            if (!isString(pattern)) {\n                throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key));\n            }\n            const obj = {\n                keyId: createKeyId(key),\n                pattern\n            };\n            if (auto) {\n                obj.searcher = createSearcher(pattern, options);\n            }\n            return obj;\n        }\n        let node = {\n            children: [],\n            operator: keys[0]\n        };\n        keys.forEach((key)=>{\n            const value = query[key];\n            if (isArray(value)) {\n                value.forEach((item)=>{\n                    node.children.push(next(item));\n                });\n            }\n        });\n        return node;\n    };\n    if (!isExpression(query)) {\n        query = convertToExplicit(query);\n    }\n    return next(query);\n}\n// Practical scoring function\nfunction computeScore(results, { ignoreFieldNorm = Config.ignoreFieldNorm }) {\n    results.forEach((result)=>{\n        let totalScore = 1;\n        result.matches.forEach(({ key, norm, score })=>{\n            const weight = key ? key.weight : null;\n            totalScore *= Math.pow(score === 0 && weight ? Number.EPSILON : score, (weight || 1) * (ignoreFieldNorm ? 1 : norm));\n        });\n        result.score = totalScore;\n    });\n}\nfunction transformMatches(result, data) {\n    const matches = result.matches;\n    data.matches = [];\n    if (!isDefined(matches)) {\n        return;\n    }\n    matches.forEach((match)=>{\n        if (!isDefined(match.indices) || !match.indices.length) {\n            return;\n        }\n        const { indices, value } = match;\n        let obj = {\n            indices,\n            value\n        };\n        if (match.key) {\n            obj.key = match.key.src;\n        }\n        if (match.idx > -1) {\n            obj.refIndex = match.idx;\n        }\n        data.matches.push(obj);\n    });\n}\nfunction transformScore(result, data) {\n    data.score = result.score;\n}\nfunction format(results, docs, { includeMatches = Config.includeMatches, includeScore = Config.includeScore } = {}) {\n    const transformers = [];\n    if (includeMatches) transformers.push(transformMatches);\n    if (includeScore) transformers.push(transformScore);\n    return results.map((result)=>{\n        const { idx } = result;\n        const data = {\n            item: docs[idx],\n            refIndex: idx\n        };\n        if (transformers.length) {\n            transformers.forEach((transformer)=>{\n                transformer(result, data);\n            });\n        }\n        return data;\n    });\n}\nclass Fuse {\n    constructor(docs, options = {}, index){\n        this.options = {\n            ...Config,\n            ...options\n        };\n        if (this.options.useExtendedSearch && !true) {}\n        this._keyStore = new KeyStore(this.options.keys);\n        this.setCollection(docs, index);\n    }\n    setCollection(docs, index) {\n        this._docs = docs;\n        if (index && !(index instanceof FuseIndex)) {\n            throw new Error(INCORRECT_INDEX_TYPE);\n        }\n        this._myIndex = index || createIndex(this.options.keys, this._docs, {\n            getFn: this.options.getFn,\n            fieldNormWeight: this.options.fieldNormWeight\n        });\n    }\n    add(doc) {\n        if (!isDefined(doc)) {\n            return;\n        }\n        this._docs.push(doc);\n        this._myIndex.add(doc);\n    }\n    remove(predicate = ()=>false) {\n        const results = [];\n        for(let i = 0, len = this._docs.length; i < len; i += 1){\n            const doc = this._docs[i];\n            if (predicate(doc, i)) {\n                this.removeAt(i);\n                i -= 1;\n                len -= 1;\n                results.push(doc);\n            }\n        }\n        return results;\n    }\n    removeAt(idx) {\n        this._docs.splice(idx, 1);\n        this._myIndex.removeAt(idx);\n    }\n    getIndex() {\n        return this._myIndex;\n    }\n    search(query, { limit = -1 } = {}) {\n        const { includeMatches, includeScore, shouldSort, sortFn, ignoreFieldNorm } = this.options;\n        let results = isString(query) ? isString(this._docs[0]) ? this._searchStringList(query) : this._searchObjectList(query) : this._searchLogical(query);\n        computeScore(results, {\n            ignoreFieldNorm\n        });\n        if (shouldSort) {\n            results.sort(sortFn);\n        }\n        if (isNumber(limit) && limit > -1) {\n            results = results.slice(0, limit);\n        }\n        return format(results, this._docs, {\n            includeMatches,\n            includeScore\n        });\n    }\n    _searchStringList(query) {\n        const searcher = createSearcher(query, this.options);\n        const { records } = this._myIndex;\n        const results = [];\n        // Iterate over every string in the index\n        records.forEach(({ v: text, i: idx, n: norm })=>{\n            if (!isDefined(text)) {\n                return;\n            }\n            const { isMatch, score, indices } = searcher.searchIn(text);\n            if (isMatch) {\n                results.push({\n                    item: text,\n                    idx,\n                    matches: [\n                        {\n                            score,\n                            value: text,\n                            norm,\n                            indices\n                        }\n                    ]\n                });\n            }\n        });\n        return results;\n    }\n    _searchLogical(query) {\n        const expression = parse(query, this.options);\n        const evaluate = (node, item, idx)=>{\n            if (!node.children) {\n                const { keyId, searcher } = node;\n                const matches = this._findMatches({\n                    key: this._keyStore.get(keyId),\n                    value: this._myIndex.getValueForItemAtKeyId(item, keyId),\n                    searcher\n                });\n                if (matches && matches.length) {\n                    return [\n                        {\n                            idx,\n                            item,\n                            matches\n                        }\n                    ];\n                }\n                return [];\n            }\n            const res = [];\n            for(let i = 0, len = node.children.length; i < len; i += 1){\n                const child = node.children[i];\n                const result = evaluate(child, item, idx);\n                if (result.length) {\n                    res.push(...result);\n                } else if (node.operator === LogicalOperator.AND) {\n                    return [];\n                }\n            }\n            return res;\n        };\n        const records = this._myIndex.records;\n        const resultMap = {};\n        const results = [];\n        records.forEach(({ $: item, i: idx })=>{\n            if (isDefined(item)) {\n                let expResults = evaluate(expression, item, idx);\n                if (expResults.length) {\n                    // Dedupe when adding\n                    if (!resultMap[idx]) {\n                        resultMap[idx] = {\n                            idx,\n                            item,\n                            matches: []\n                        };\n                        results.push(resultMap[idx]);\n                    }\n                    expResults.forEach(({ matches })=>{\n                        resultMap[idx].matches.push(...matches);\n                    });\n                }\n            }\n        });\n        return results;\n    }\n    _searchObjectList(query) {\n        const searcher = createSearcher(query, this.options);\n        const { keys, records } = this._myIndex;\n        const results = [];\n        // List is Array<Object>\n        records.forEach(({ $: item, i: idx })=>{\n            if (!isDefined(item)) {\n                return;\n            }\n            let matches = [];\n            // Iterate over every key (i.e, path), and fetch the value at that key\n            keys.forEach((key, keyIndex)=>{\n                matches.push(...this._findMatches({\n                    key,\n                    value: item[keyIndex],\n                    searcher\n                }));\n            });\n            if (matches.length) {\n                results.push({\n                    idx,\n                    item,\n                    matches\n                });\n            }\n        });\n        return results;\n    }\n    _findMatches({ key, value, searcher }) {\n        if (!isDefined(value)) {\n            return [];\n        }\n        let matches = [];\n        if (isArray(value)) {\n            value.forEach(({ v: text, i: idx, n: norm })=>{\n                if (!isDefined(text)) {\n                    return;\n                }\n                const { isMatch, score, indices } = searcher.searchIn(text);\n                if (isMatch) {\n                    matches.push({\n                        score,\n                        key,\n                        value: text,\n                        idx,\n                        norm,\n                        indices\n                    });\n                }\n            });\n        } else {\n            const { v: text, n: norm } = value;\n            const { isMatch, score, indices } = searcher.searchIn(text);\n            if (isMatch) {\n                matches.push({\n                    score,\n                    key,\n                    value: text,\n                    norm,\n                    indices\n                });\n            }\n        }\n        return matches;\n    }\n}\nFuse.version = \"6.6.2\";\nFuse.createIndex = createIndex;\nFuse.parseIndex = parseIndex;\nFuse.config = Config;\n{\n    Fuse.parseQuery = parse;\n}{\n    register(ExtendedSearch);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vZnVzZS5qc0A2LjYuMi9ub2RlX21vZHVsZXMvZnVzZS5qcy9kaXN0L2Z1c2UuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7Ozs7OztDQU9DLEdBRUQsU0FBU0EsUUFBUUMsS0FBSztJQUNwQixPQUFPLENBQUNDLE1BQU1GLE9BQU8sR0FDakJHLE9BQU9GLFdBQVcsbUJBQ2xCQyxNQUFNRixPQUFPLENBQUNDO0FBQ3BCO0FBRUEsdUZBQXVGO0FBQ3ZGLE1BQU1HLFdBQVcsSUFBSTtBQUNyQixTQUFTQyxhQUFhSixLQUFLO0lBQ3pCLDBFQUEwRTtJQUMxRSxJQUFJLE9BQU9BLFNBQVMsVUFBVTtRQUM1QixPQUFPQTtJQUNUO0lBQ0EsSUFBSUssU0FBU0wsUUFBUTtJQUNyQixPQUFPSyxVQUFVLE9BQU8sSUFBSUwsU0FBUyxDQUFDRyxXQUFXLE9BQU9FO0FBQzFEO0FBRUEsU0FBU0MsU0FBU04sS0FBSztJQUNyQixPQUFPQSxTQUFTLE9BQU8sS0FBS0ksYUFBYUo7QUFDM0M7QUFFQSxTQUFTTyxTQUFTUCxLQUFLO0lBQ3JCLE9BQU8sT0FBT0EsVUFBVTtBQUMxQjtBQUVBLFNBQVNRLFNBQVNSLEtBQUs7SUFDckIsT0FBTyxPQUFPQSxVQUFVO0FBQzFCO0FBRUEsMEVBQTBFO0FBQzFFLFNBQVNTLFVBQVVULEtBQUs7SUFDdEIsT0FDRUEsVUFBVSxRQUNWQSxVQUFVLFNBQ1RVLGFBQWFWLFVBQVVFLE9BQU9GLFVBQVU7QUFFN0M7QUFFQSxTQUFTVyxTQUFTWCxLQUFLO0lBQ3JCLE9BQU8sT0FBT0EsVUFBVTtBQUMxQjtBQUVBLG9DQUFvQztBQUNwQyxTQUFTVSxhQUFhVixLQUFLO0lBQ3pCLE9BQU9XLFNBQVNYLFVBQVVBLFVBQVU7QUFDdEM7QUFFQSxTQUFTWSxVQUFVWixLQUFLO0lBQ3RCLE9BQU9BLFVBQVVhLGFBQWFiLFVBQVU7QUFDMUM7QUFFQSxTQUFTYyxRQUFRZCxLQUFLO0lBQ3BCLE9BQU8sQ0FBQ0Es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QUFRO1lBQ2xCQSxNQUFNcUMsT0FBTyxDQUFDLENBQUMsRUFBRW9GLEdBQUc2QixJQUFJLEVBQUUxRixHQUFHYyxHQUFHLEVBQUVzQixHQUFHVixJQUFJLEVBQUU7Z0JBQ3pDLElBQUksQ0FBQzFFLFVBQVUwSSxPQUFPO29CQUNwQjtnQkFDRjtnQkFFQSxNQUFNLEVBQUVzQixPQUFPLEVBQUVuRyxLQUFLLEVBQUV3RSxPQUFPLEVBQUUsR0FBR3lFLFNBQVNsQyxRQUFRLENBQUNsQztnQkFFdEQsSUFBSXNCLFNBQVM7b0JBQ1h1QixRQUFRMUosSUFBSSxDQUFDO3dCQUNYZ0M7d0JBQ0FsRDt3QkFDQXZCLE9BQU9zSjt3QkFDUDVFO3dCQUNBWTt3QkFDQTJEO29CQUNGO2dCQUNGO1lBQ0Y7UUFDRixPQUFPO1lBQ0wsTUFBTSxFQUFFeEIsR0FBRzZCLElBQUksRUFBRXRELEdBQUdWLElBQUksRUFBRSxHQUFHdEY7WUFFN0IsTUFBTSxFQUFFNEssT0FBTyxFQUFFbkcsS0FBSyxFQUFFd0UsT0FBTyxFQUFFLEdBQUd5RSxTQUFTbEMsUUFBUSxDQUFDbEM7WUFFdEQsSUFBSXNCLFNBQVM7Z0JBQ1h1QixRQUFRMUosSUFBSSxDQUFDO29CQUFFZ0M7b0JBQU9sRDtvQkFBS3ZCLE9BQU9zSjtvQkFBTWhFO29CQUFNMkQ7Z0JBQVE7WUFDeEQ7UUFDRjtRQUVBLE9BQU9rRDtJQUNUO0FBQ0Y7QUFFQWdFLEtBQUtxQixPQUFPLEdBQUc7QUFDZnJCLEtBQUtqSSxXQUFXLEdBQUdBO0FBQ25CaUksS0FBSzlILFVBQVUsR0FBR0E7QUFDbEI4SCxLQUFLc0IsTUFBTSxHQUFHck07QUFFZDtJQUNFK0ssS0FBSy9DLFVBQVUsR0FBRytCO0FBQ3BCLENBRUE7SUFDRWQsU0FBU1A7QUFDWCxDQUUyQiIsInNvdXJjZXMiOlsid2VicGFjazovL3RhaWx3aW5kLW5leHRqcy1zdGFydGVyLWJsb2cvLi9ub2RlX21vZHVsZXMvLnBucG0vZnVzZS5qc0A2LjYuMi9ub2RlX21vZHVsZXMvZnVzZS5qcy9kaXN0L2Z1c2UuZXNtLmpzPzVkZjMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBGdXNlLmpzIHY2LjYuMiAtIExpZ2h0d2VpZ2h0IGZ1enp5LXNlYXJjaCAoaHR0cDovL2Z1c2Vqcy5pbylcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjIgS2lybyBSaXNrIChodHRwOi8va2lyby5tZSlcbiAqIEFsbCBSaWdodHMgUmVzZXJ2ZWQuIEFwYWNoZSBTb2Z0d2FyZSBMaWNlbnNlIDIuMFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICovXG5cbmZ1bmN0aW9uIGlzQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuICFBcnJheS5pc0FycmF5XG4gICAgPyBnZXRUYWcodmFsdWUpID09PSAnW29iamVjdCBBcnJheV0nXG4gICAgOiBBcnJheS5pc0FycmF5KHZhbHVlKVxufVxuXG4vLyBBZGFwdGVkIGZyb206IGh0dHBzOi8vZ2l0aHViLmNvbS9sb2Rhc2gvbG9kYXNoL2Jsb2IvbWFzdGVyLy5pbnRlcm5hbC9iYXNlVG9TdHJpbmcuanNcbmNvbnN0IElORklOSVRZID0gMSAvIDA7XG5mdW5jdGlvbiBiYXNlVG9TdHJpbmcodmFsdWUpIHtcbiAgLy8gRXhpdCBlYXJseSBmb3Igc3RyaW5ncyB0byBhdm9pZCBhIHBlcmZvcm1hbmNlIGhpdCBpbiBzb21lIGVudmlyb25tZW50cy5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZVxuICB9XG4gIGxldCByZXN1bHQgPSB2YWx1ZSArICcnO1xuICByZXR1cm4gcmVzdWx0ID09ICcwJyAmJiAxIC8gdmFsdWUgPT0gLUlORklOSVRZID8gJy0wJyA6IHJlc3VsdFxufVxuXG5mdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogYmFzZVRvU3RyaW5nKHZhbHVlKVxufVxuXG5mdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJ1xufVxuXG5mdW5jdGlvbiBpc051bWJlcih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJ1xufVxuXG4vLyBBZGFwdGVkIGZyb206IGh0dHBzOi8vZ2l0aHViLmNvbS9sb2Rhc2gvbG9kYXNoL2Jsb2IvbWFzdGVyL2lzQm9vbGVhbi5qc1xuZnVuY3Rpb24gaXNCb29sZWFuKHZhbHVlKSB7XG4gIHJldHVybiAoXG4gICAgdmFsdWUgPT09IHRydWUgfHxcbiAgICB2YWx1ZSA9PT0gZmFsc2UgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBnZXRUYWcodmFsdWUpID09ICdbb2JqZWN0IEJvb2xlYW5dJylcbiAgKVxufVxuXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0J1xufVxuXG4vLyBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS5cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIHZhbHVlICE9PSBudWxsXG59XG5cbmZ1bmN0aW9uIGlzRGVmaW5lZCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbFxufVxuXG5mdW5jdGlvbiBpc0JsYW5rKHZhbHVlKSB7XG4gIHJldHVybiAhdmFsdWUudHJpbSgpLmxlbmd0aFxufVxuXG4vLyBHZXRzIHRoZSBgdG9TdHJpbmdUYWdgIG9mIGB2YWx1ZWAuXG4vLyBBZGFwdGVkIGZyb206IGh0dHBzOi8vZ2l0aHViLmNvbS9sb2Rhc2gvbG9kYXNoL2Jsb2IvbWFzdGVyLy5pbnRlcm5hbC9nZXRUYWcuanNcbmZ1bmN0aW9uIGdldFRhZyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbFxuICAgID8gdmFsdWUgPT09IHVuZGVmaW5lZFxuICAgICAgPyAnW29iamVjdCBVbmRlZmluZWRdJ1xuICAgICAgOiAnW29iamVjdCBOdWxsXSdcbiAgICA6IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSlcbn1cblxuY29uc3QgRVhURU5ERURfU0VBUkNIX1VOQVZBSUxBQkxFID0gJ0V4dGVuZGVkIHNlYXJjaCBpcyBub3QgYXZhaWxhYmxlJztcblxuY29uc3QgSU5DT1JSRUNUX0lOREVYX1RZUEUgPSBcIkluY29ycmVjdCAnaW5kZXgnIHR5cGVcIjtcblxuY29uc3QgTE9HSUNBTF9TRUFSQ0hfSU5WQUxJRF9RVUVSWV9GT1JfS0VZID0gKGtleSkgPT5cbiAgYEludmFsaWQgdmFsdWUgZm9yIGtleSAke2tleX1gO1xuXG5jb25zdCBQQVRURVJOX0xFTkdUSF9UT09fTEFSR0UgPSAobWF4KSA9PlxuICBgUGF0dGVybiBsZW5ndGggZXhjZWVkcyBtYXggb2YgJHttYXh9LmA7XG5cbmNvbnN0IE1JU1NJTkdfS0VZX1BST1BFUlRZID0gKG5hbWUpID0+IGBNaXNzaW5nICR7bmFtZX0gcHJvcGVydHkgaW4ga2V5YDtcblxuY29uc3QgSU5WQUxJRF9LRVlfV0VJR0hUX1ZBTFVFID0gKGtleSkgPT5cbiAgYFByb3BlcnR5ICd3ZWlnaHQnIGluIGtleSAnJHtrZXl9JyBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlcmA7XG5cbmNvbnN0IGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmNsYXNzIEtleVN0b3JlIHtcbiAgY29uc3RydWN0b3Ioa2V5cykge1xuICAgIHRoaXMuX2tleXMgPSBbXTtcbiAgICB0aGlzLl9rZXlNYXAgPSB7fTtcblxuICAgIGxldCB0b3RhbFdlaWdodCA9IDA7XG5cbiAgICBrZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgbGV0IG9iaiA9IGNyZWF0ZUtleShrZXkpO1xuXG4gICAgICB0b3RhbFdlaWdodCArPSBvYmoud2VpZ2h0O1xuXG4gICAgICB0aGlzLl9rZXlzLnB1c2gob2JqKTtcbiAgICAgIHRoaXMuX2tleU1hcFtvYmouaWRdID0gb2JqO1xuXG4gICAgICB0b3RhbFdlaWdodCArPSBvYmoud2VpZ2h0O1xuICAgIH0pO1xuXG4gICAgLy8gTm9ybWFsaXplIHdlaWdodHMgc28gdGhhdCB0aGVpciBzdW0gaXMgZXF1YWwgdG8gMVxuICAgIHRoaXMuX2tleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBrZXkud2VpZ2h0IC89IHRvdGFsV2VpZ2h0O1xuICAgIH0pO1xuICB9XG4gIGdldChrZXlJZCkge1xuICAgIHJldHVybiB0aGlzLl9rZXlNYXBba2V5SWRdXG4gIH1cbiAga2V5cygpIHtcbiAgICByZXR1cm4gdGhpcy5fa2V5c1xuICB9XG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy5fa2V5cylcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVLZXkoa2V5KSB7XG4gIGxldCBwYXRoID0gbnVsbDtcbiAgbGV0IGlkID0gbnVsbDtcbiAgbGV0IHNyYyA9IG51bGw7XG4gIGxldCB3ZWlnaHQgPSAxO1xuICBsZXQgZ2V0Rm4gPSBudWxsO1xuXG4gIGlmIChpc1N0cmluZyhrZXkpIHx8IGlzQXJyYXkoa2V5KSkge1xuICAgIHNyYyA9IGtleTtcbiAgICBwYXRoID0gY3JlYXRlS2V5UGF0aChrZXkpO1xuICAgIGlkID0gY3JlYXRlS2V5SWQoa2V5KTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoIWhhc093bi5jYWxsKGtleSwgJ25hbWUnKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKE1JU1NJTkdfS0VZX1BST1BFUlRZKCduYW1lJykpXG4gICAgfVxuXG4gICAgY29uc3QgbmFtZSA9IGtleS5uYW1lO1xuICAgIHNyYyA9IG5hbWU7XG5cbiAgICBpZiAoaGFzT3duLmNhbGwoa2V5LCAnd2VpZ2h0JykpIHtcbiAgICAgIHdlaWdodCA9IGtleS53ZWlnaHQ7XG5cbiAgICAgIGlmICh3ZWlnaHQgPD0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSU5WQUxJRF9LRVlfV0VJR0hUX1ZBTFVFKG5hbWUpKVxuICAgICAgfVxuICAgIH1cblxuICAgIHBhdGggPSBjcmVhdGVLZXlQYXRoKG5hbWUpO1xuICAgIGlkID0gY3JlYXRlS2V5SWQobmFtZSk7XG4gICAgZ2V0Rm4gPSBrZXkuZ2V0Rm47XG4gIH1cblxuICByZXR1cm4geyBwYXRoLCBpZCwgd2VpZ2h0LCBzcmMsIGdldEZuIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlS2V5UGF0aChrZXkpIHtcbiAgcmV0dXJuIGlzQXJyYXkoa2V5KSA/IGtleSA6IGtleS5zcGxpdCgnLicpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUtleUlkKGtleSkge1xuICByZXR1cm4gaXNBcnJheShrZXkpID8ga2V5LmpvaW4oJy4nKSA6IGtleVxufVxuXG5mdW5jdGlvbiBnZXQob2JqLCBwYXRoKSB7XG4gIGxldCBsaXN0ID0gW107XG4gIGxldCBhcnIgPSBmYWxzZTtcblxuICBjb25zdCBkZWVwR2V0ID0gKG9iaiwgcGF0aCwgaW5kZXgpID0+IHtcbiAgICBpZiAoIWlzRGVmaW5lZChvYmopKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgaWYgKCFwYXRoW2luZGV4XSkge1xuICAgICAgLy8gSWYgdGhlcmUncyBubyBwYXRoIGxlZnQsIHdlJ3ZlIGFycml2ZWQgYXQgdGhlIG9iamVjdCB3ZSBjYXJlIGFib3V0LlxuICAgICAgbGlzdC5wdXNoKG9iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBrZXkgPSBwYXRoW2luZGV4XTtcblxuICAgICAgY29uc3QgdmFsdWUgPSBvYmpba2V5XTtcblxuICAgICAgaWYgKCFpc0RlZmluZWQodmFsdWUpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyBJZiB3ZSdyZSBhdCB0aGUgbGFzdCB2YWx1ZSBpbiB0aGUgcGF0aCwgYW5kIGlmIGl0J3MgYSBzdHJpbmcvbnVtYmVyL2Jvb2wsXG4gICAgICAvLyBhZGQgaXQgdG8gdGhlIGxpc3RcbiAgICAgIGlmIChcbiAgICAgICAgaW5kZXggPT09IHBhdGgubGVuZ3RoIC0gMSAmJlxuICAgICAgICAoaXNTdHJpbmcodmFsdWUpIHx8IGlzTnVtYmVyKHZhbHVlKSB8fCBpc0Jvb2xlYW4odmFsdWUpKVxuICAgICAgKSB7XG4gICAgICAgIGxpc3QucHVzaCh0b1N0cmluZyh2YWx1ZSkpO1xuICAgICAgfSBlbHNlIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBhcnIgPSB0cnVlO1xuICAgICAgICAvLyBTZWFyY2ggZWFjaCBpdGVtIGluIHRoZSBhcnJheS5cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHZhbHVlLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgZGVlcEdldCh2YWx1ZVtpXSwgcGF0aCwgaW5kZXggKyAxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwYXRoLmxlbmd0aCkge1xuICAgICAgICAvLyBBbiBvYmplY3QuIFJlY3Vyc2UgZnVydGhlci5cbiAgICAgICAgZGVlcEdldCh2YWx1ZSwgcGF0aCwgaW5kZXggKyAxKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHkgKHNpbmNlIHBhdGggdXNlZCB0byBiZSBhIHN0cmluZylcbiAgZGVlcEdldChvYmosIGlzU3RyaW5nKHBhdGgpID8gcGF0aC5zcGxpdCgnLicpIDogcGF0aCwgMCk7XG5cbiAgcmV0dXJuIGFyciA/IGxpc3QgOiBsaXN0WzBdXG59XG5cbmNvbnN0IE1hdGNoT3B0aW9ucyA9IHtcbiAgLy8gV2hldGhlciB0aGUgbWF0Y2hlcyBzaG91bGQgYmUgaW5jbHVkZWQgaW4gdGhlIHJlc3VsdCBzZXQuIFdoZW4gYHRydWVgLCBlYWNoIHJlY29yZCBpbiB0aGUgcmVzdWx0XG4gIC8vIHNldCB3aWxsIGluY2x1ZGUgdGhlIGluZGljZXMgb2YgdGhlIG1hdGNoZWQgY2hhcmFjdGVycy5cbiAgLy8gVGhlc2UgY2FuIGNvbnNlcXVlbnRseSBiZSB1c2VkIGZvciBoaWdobGlnaHRpbmcgcHVycG9zZXMuXG4gIGluY2x1ZGVNYXRjaGVzOiBmYWxzZSxcbiAgLy8gV2hlbiBgdHJ1ZWAsIHRoZSBtYXRjaGluZyBmdW5jdGlvbiB3aWxsIGNvbnRpbnVlIHRvIHRoZSBlbmQgb2YgYSBzZWFyY2ggcGF0dGVybiBldmVuIGlmXG4gIC8vIGEgcGVyZmVjdCBtYXRjaCBoYXMgYWxyZWFkeSBiZWVuIGxvY2F0ZWQgaW4gdGhlIHN0cmluZy5cbiAgZmluZEFsbE1hdGNoZXM6IGZhbHNlLFxuICAvLyBNaW5pbXVtIG51bWJlciBvZiBjaGFyYWN0ZXJzIHRoYXQgbXVzdCBiZSBtYXRjaGVkIGJlZm9yZSBhIHJlc3VsdCBpcyBjb25zaWRlcmVkIGEgbWF0Y2hcbiAgbWluTWF0Y2hDaGFyTGVuZ3RoOiAxXG59O1xuXG5jb25zdCBCYXNpY09wdGlvbnMgPSB7XG4gIC8vIFdoZW4gYHRydWVgLCB0aGUgYWxnb3JpdGhtIGNvbnRpbnVlcyBzZWFyY2hpbmcgdG8gdGhlIGVuZCBvZiB0aGUgaW5wdXQgZXZlbiBpZiBhIHBlcmZlY3RcbiAgLy8gbWF0Y2ggaXMgZm91bmQgYmVmb3JlIHRoZSBlbmQgb2YgdGhlIHNhbWUgaW5wdXQuXG4gIGlzQ2FzZVNlbnNpdGl2ZTogZmFsc2UsXG4gIC8vIFdoZW4gdHJ1ZSwgdGhlIG1hdGNoaW5nIGZ1bmN0aW9uIHdpbGwgY29udGludWUgdG8gdGhlIGVuZCBvZiBhIHNlYXJjaCBwYXR0ZXJuIGV2ZW4gaWZcbiAgaW5jbHVkZVNjb3JlOiBmYWxzZSxcbiAgLy8gTGlzdCBvZiBwcm9wZXJ0aWVzIHRoYXQgd2lsbCBiZSBzZWFyY2hlZC4gVGhpcyBhbHNvIHN1cHBvcnRzIG5lc3RlZCBwcm9wZXJ0aWVzLlxuICBrZXlzOiBbXSxcbiAgLy8gV2hldGhlciB0byBzb3J0IHRoZSByZXN1bHQgbGlzdCwgYnkgc2NvcmVcbiAgc2hvdWxkU29ydDogdHJ1ZSxcbiAgLy8gRGVmYXVsdCBzb3J0IGZ1bmN0aW9uOiBzb3J0IGJ5IGFzY2VuZGluZyBzY29yZSwgYXNjZW5kaW5nIGluZGV4XG4gIHNvcnRGbjogKGEsIGIpID0+XG4gICAgYS5zY29yZSA9PT0gYi5zY29yZSA/IChhLmlkeCA8IGIuaWR4ID8gLTEgOiAxKSA6IGEuc2NvcmUgPCBiLnNjb3JlID8gLTEgOiAxXG59O1xuXG5jb25zdCBGdXp6eU9wdGlvbnMgPSB7XG4gIC8vIEFwcHJveGltYXRlbHkgd2hlcmUgaW4gdGhlIHRleHQgaXMgdGhlIHBhdHRlcm4gZXhwZWN0ZWQgdG8gYmUgZm91bmQ/XG4gIGxvY2F0aW9uOiAwLFxuICAvLyBBdCB3aGF0IHBvaW50IGRvZXMgdGhlIG1hdGNoIGFsZ29yaXRobSBnaXZlIHVwLiBBIHRocmVzaG9sZCBvZiAnMC4wJyByZXF1aXJlcyBhIHBlcmZlY3QgbWF0Y2hcbiAgLy8gKG9mIGJvdGggbGV0dGVycyBhbmQgbG9jYXRpb24pLCBhIHRocmVzaG9sZCBvZiAnMS4wJyB3b3VsZCBtYXRjaCBhbnl0aGluZy5cbiAgdGhyZXNob2xkOiAwLjYsXG4gIC8vIERldGVybWluZXMgaG93IGNsb3NlIHRoZSBtYXRjaCBtdXN0IGJlIHRvIHRoZSBmdXp6eSBsb2NhdGlvbiAoc3BlY2lmaWVkIGFib3ZlKS5cbiAgLy8gQW4gZXhhY3QgbGV0dGVyIG1hdGNoIHdoaWNoIGlzICdkaXN0YW5jZScgY2hhcmFjdGVycyBhd2F5IGZyb20gdGhlIGZ1enp5IGxvY2F0aW9uXG4gIC8vIHdvdWxkIHNjb3JlIGFzIGEgY29tcGxldGUgbWlzbWF0Y2guIEEgZGlzdGFuY2Ugb2YgJzAnIHJlcXVpcmVzIHRoZSBtYXRjaCBiZSBhdFxuICAvLyB0aGUgZXhhY3QgbG9jYXRpb24gc3BlY2lmaWVkLCBhIHRocmVzaG9sZCBvZiAnMTAwMCcgd291bGQgcmVxdWlyZSBhIHBlcmZlY3QgbWF0Y2hcbiAgLy8gdG8gYmUgd2l0aGluIDgwMCBjaGFyYWN0ZXJzIG9mIHRoZSBmdXp6eSBsb2NhdGlvbiB0byBiZSBmb3VuZCB1c2luZyBhIDAuOCB0aHJlc2hvbGQuXG4gIGRpc3RhbmNlOiAxMDBcbn07XG5cbmNvbnN0IEFkdmFuY2VkT3B0aW9ucyA9IHtcbiAgLy8gV2hlbiBgdHJ1ZWAsIGl0IGVuYWJsZXMgdGhlIHVzZSBvZiB1bml4LWxpa2Ugc2VhcmNoIGNvbW1hbmRzXG4gIHVzZUV4dGVuZGVkU2VhcmNoOiBmYWxzZSxcbiAgLy8gVGhlIGdldCBmdW5jdGlvbiB0byB1c2Ugd2hlbiBmZXRjaGluZyBhbiBvYmplY3QncyBwcm9wZXJ0aWVzLlxuICAvLyBUaGUgZGVmYXVsdCB3aWxsIHNlYXJjaCBuZXN0ZWQgcGF0aHMgKmllIGZvby5iYXIuYmF6KlxuICBnZXRGbjogZ2V0LFxuICAvLyBXaGVuIGB0cnVlYCwgc2VhcmNoIHdpbGwgaWdub3JlIGBsb2NhdGlvbmAgYW5kIGBkaXN0YW5jZWAsIHNvIGl0IHdvbid0IG1hdHRlclxuICAvLyB3aGVyZSBpbiB0aGUgc3RyaW5nIHRoZSBwYXR0ZXJuIGFwcGVhcnMuXG4gIC8vIE1vcmUgaW5mbzogaHR0cHM6Ly9mdXNlanMuaW8vY29uY2VwdHMvc2NvcmluZy10aGVvcnkuaHRtbCNmdXp6aW5lc3Mtc2NvcmVcbiAgaWdub3JlTG9jYXRpb246IGZhbHNlLFxuICAvLyBXaGVuIGB0cnVlYCwgdGhlIGNhbGN1bGF0aW9uIGZvciB0aGUgcmVsZXZhbmNlIHNjb3JlICh1c2VkIGZvciBzb3J0aW5nKSB3aWxsXG4gIC8vIGlnbm9yZSB0aGUgZmllbGQtbGVuZ3RoIG5vcm0uXG4gIC8vIE1vcmUgaW5mbzogaHR0cHM6Ly9mdXNlanMuaW8vY29uY2VwdHMvc2NvcmluZy10aGVvcnkuaHRtbCNmaWVsZC1sZW5ndGgtbm9ybVxuICBpZ25vcmVGaWVsZE5vcm06IGZhbHNlLFxuICAvLyBUaGUgd2VpZ2h0IHRvIGRldGVybWluZSBob3cgbXVjaCBmaWVsZCBsZW5ndGggbm9ybSBlZmZlY3RzIHNjb3JpbmcuXG4gIGZpZWxkTm9ybVdlaWdodDogMVxufTtcblxudmFyIENvbmZpZyA9IHtcbiAgLi4uQmFzaWNPcHRpb25zLFxuICAuLi5NYXRjaE9wdGlvbnMsXG4gIC4uLkZ1enp5T3B0aW9ucyxcbiAgLi4uQWR2YW5jZWRPcHRpb25zXG59O1xuXG5jb25zdCBTUEFDRSA9IC9bXiBdKy9nO1xuXG4vLyBGaWVsZC1sZW5ndGggbm9ybTogdGhlIHNob3J0ZXIgdGhlIGZpZWxkLCB0aGUgaGlnaGVyIHRoZSB3ZWlnaHQuXG4vLyBTZXQgdG8gMyBkZWNpbWFscyB0byByZWR1Y2UgaW5kZXggc2l6ZS5cbmZ1bmN0aW9uIG5vcm0od2VpZ2h0ID0gMSwgbWFudGlzc2EgPSAzKSB7XG4gIGNvbnN0IGNhY2hlID0gbmV3IE1hcCgpO1xuICBjb25zdCBtID0gTWF0aC5wb3coMTAsIG1hbnRpc3NhKTtcblxuICByZXR1cm4ge1xuICAgIGdldCh2YWx1ZSkge1xuICAgICAgY29uc3QgbnVtVG9rZW5zID0gdmFsdWUubWF0Y2goU1BBQ0UpLmxlbmd0aDtcblxuICAgICAgaWYgKGNhY2hlLmhhcyhudW1Ub2tlbnMpKSB7XG4gICAgICAgIHJldHVybiBjYWNoZS5nZXQobnVtVG9rZW5zKVxuICAgICAgfVxuXG4gICAgICAvLyBEZWZhdWx0IGZ1bmN0aW9uIGlzIDEvc3FydCh4KSwgd2VpZ2h0IG1ha2VzIHRoYXQgdmFyaWFibGVcbiAgICAgIGNvbnN0IG5vcm0gPSAxIC8gTWF0aC5wb3cobnVtVG9rZW5zLCAwLjUgKiB3ZWlnaHQpO1xuXG4gICAgICAvLyBJbiBwbGFjZSBvZiBgdG9GaXhlZChtYW50aXNzYSlgLCBmb3IgZmFzdGVyIGNvbXB1dGF0aW9uXG4gICAgICBjb25zdCBuID0gcGFyc2VGbG9hdChNYXRoLnJvdW5kKG5vcm0gKiBtKSAvIG0pO1xuXG4gICAgICBjYWNoZS5zZXQobnVtVG9rZW5zLCBuKTtcblxuICAgICAgcmV0dXJuIG5cbiAgICB9LFxuICAgIGNsZWFyKCkge1xuICAgICAgY2FjaGUuY2xlYXIoKTtcbiAgICB9XG4gIH1cbn1cblxuY2xhc3MgRnVzZUluZGV4IHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGdldEZuID0gQ29uZmlnLmdldEZuLFxuICAgIGZpZWxkTm9ybVdlaWdodCA9IENvbmZpZy5maWVsZE5vcm1XZWlnaHRcbiAgfSA9IHt9KSB7XG4gICAgdGhpcy5ub3JtID0gbm9ybShmaWVsZE5vcm1XZWlnaHQsIDMpO1xuICAgIHRoaXMuZ2V0Rm4gPSBnZXRGbjtcbiAgICB0aGlzLmlzQ3JlYXRlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5zZXRJbmRleFJlY29yZHMoKTtcbiAgfVxuICBzZXRTb3VyY2VzKGRvY3MgPSBbXSkge1xuICAgIHRoaXMuZG9jcyA9IGRvY3M7XG4gIH1cbiAgc2V0SW5kZXhSZWNvcmRzKHJlY29yZHMgPSBbXSkge1xuICAgIHRoaXMucmVjb3JkcyA9IHJlY29yZHM7XG4gIH1cbiAgc2V0S2V5cyhrZXlzID0gW10pIHtcbiAgICB0aGlzLmtleXMgPSBrZXlzO1xuICAgIHRoaXMuX2tleXNNYXAgPSB7fTtcbiAgICBrZXlzLmZvckVhY2goKGtleSwgaWR4KSA9PiB7XG4gICAgICB0aGlzLl9rZXlzTWFwW2tleS5pZF0gPSBpZHg7XG4gICAgfSk7XG4gIH1cbiAgY3JlYXRlKCkge1xuICAgIGlmICh0aGlzLmlzQ3JlYXRlZCB8fCAhdGhpcy5kb2NzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5pc0NyZWF0ZWQgPSB0cnVlO1xuXG4gICAgLy8gTGlzdCBpcyBBcnJheTxTdHJpbmc+XG4gICAgaWYgKGlzU3RyaW5nKHRoaXMuZG9jc1swXSkpIHtcbiAgICAgIHRoaXMuZG9jcy5mb3JFYWNoKChkb2MsIGRvY0luZGV4KSA9PiB7XG4gICAgICAgIHRoaXMuX2FkZFN0cmluZyhkb2MsIGRvY0luZGV4KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBMaXN0IGlzIEFycmF5PE9iamVjdD5cbiAgICAgIHRoaXMuZG9jcy5mb3JFYWNoKChkb2MsIGRvY0luZGV4KSA9PiB7XG4gICAgICAgIHRoaXMuX2FkZE9iamVjdChkb2MsIGRvY0luZGV4KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMubm9ybS5jbGVhcigpO1xuICB9XG4gIC8vIEFkZHMgYSBkb2MgdG8gdGhlIGVuZCBvZiB0aGUgaW5kZXhcbiAgYWRkKGRvYykge1xuICAgIGNvbnN0IGlkeCA9IHRoaXMuc2l6ZSgpO1xuXG4gICAgaWYgKGlzU3RyaW5nKGRvYykpIHtcbiAgICAgIHRoaXMuX2FkZFN0cmluZyhkb2MsIGlkeCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2FkZE9iamVjdChkb2MsIGlkeCk7XG4gICAgfVxuICB9XG4gIC8vIFJlbW92ZXMgdGhlIGRvYyBhdCB0aGUgc3BlY2lmaWVkIGluZGV4IG9mIHRoZSBpbmRleFxuICByZW1vdmVBdChpZHgpIHtcbiAgICB0aGlzLnJlY29yZHMuc3BsaWNlKGlkeCwgMSk7XG5cbiAgICAvLyBDaGFuZ2UgcmVmIGluZGV4IG9mIGV2ZXJ5IHN1YnNxdWVudCBkb2NcbiAgICBmb3IgKGxldCBpID0gaWR4LCBsZW4gPSB0aGlzLnNpemUoKTsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICB0aGlzLnJlY29yZHNbaV0uaSAtPSAxO1xuICAgIH1cbiAgfVxuICBnZXRWYWx1ZUZvckl0ZW1BdEtleUlkKGl0ZW0sIGtleUlkKSB7XG4gICAgcmV0dXJuIGl0ZW1bdGhpcy5fa2V5c01hcFtrZXlJZF1dXG4gIH1cbiAgc2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZWNvcmRzLmxlbmd0aFxuICB9XG4gIF9hZGRTdHJpbmcoZG9jLCBkb2NJbmRleCkge1xuICAgIGlmICghaXNEZWZpbmVkKGRvYykgfHwgaXNCbGFuayhkb2MpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBsZXQgcmVjb3JkID0ge1xuICAgICAgdjogZG9jLFxuICAgICAgaTogZG9jSW5kZXgsXG4gICAgICBuOiB0aGlzLm5vcm0uZ2V0KGRvYylcbiAgICB9O1xuXG4gICAgdGhpcy5yZWNvcmRzLnB1c2gocmVjb3JkKTtcbiAgfVxuICBfYWRkT2JqZWN0KGRvYywgZG9jSW5kZXgpIHtcbiAgICBsZXQgcmVjb3JkID0geyBpOiBkb2NJbmRleCwgJDoge30gfTtcblxuICAgIC8vIEl0ZXJhdGUgb3ZlciBldmVyeSBrZXkgKGkuZSwgcGF0aCksIGFuZCBmZXRjaCB0aGUgdmFsdWUgYXQgdGhhdCBrZXlcbiAgICB0aGlzLmtleXMuZm9yRWFjaCgoa2V5LCBrZXlJbmRleCkgPT4ge1xuICAgICAgbGV0IHZhbHVlID0ga2V5LmdldEZuID8ga2V5LmdldEZuKGRvYykgOiB0aGlzLmdldEZuKGRvYywga2V5LnBhdGgpO1xuXG4gICAgICBpZiAoIWlzRGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBsZXQgc3ViUmVjb3JkcyA9IFtdO1xuICAgICAgICBjb25zdCBzdGFjayA9IFt7IG5lc3RlZEFyckluZGV4OiAtMSwgdmFsdWUgfV07XG5cbiAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnN0IHsgbmVzdGVkQXJySW5kZXgsIHZhbHVlIH0gPSBzdGFjay5wb3AoKTtcblxuICAgICAgICAgIGlmICghaXNEZWZpbmVkKHZhbHVlKSkge1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaXNTdHJpbmcodmFsdWUpICYmICFpc0JsYW5rKHZhbHVlKSkge1xuICAgICAgICAgICAgbGV0IHN1YlJlY29yZCA9IHtcbiAgICAgICAgICAgICAgdjogdmFsdWUsXG4gICAgICAgICAgICAgIGk6IG5lc3RlZEFyckluZGV4LFxuICAgICAgICAgICAgICBuOiB0aGlzLm5vcm0uZ2V0KHZhbHVlKVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgc3ViUmVjb3Jkcy5wdXNoKHN1YlJlY29yZCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgdmFsdWUuZm9yRWFjaCgoaXRlbSwgaykgPT4ge1xuICAgICAgICAgICAgICBzdGFjay5wdXNoKHtcbiAgICAgICAgICAgICAgICBuZXN0ZWRBcnJJbmRleDogayxcbiAgICAgICAgICAgICAgICB2YWx1ZTogaXRlbVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSA7XG4gICAgICAgIH1cbiAgICAgICAgcmVjb3JkLiRba2V5SW5kZXhdID0gc3ViUmVjb3JkcztcbiAgICAgIH0gZWxzZSBpZiAoaXNTdHJpbmcodmFsdWUpICYmICFpc0JsYW5rKHZhbHVlKSkge1xuICAgICAgICBsZXQgc3ViUmVjb3JkID0ge1xuICAgICAgICAgIHY6IHZhbHVlLFxuICAgICAgICAgIG46IHRoaXMubm9ybS5nZXQodmFsdWUpXG4gICAgICAgIH07XG5cbiAgICAgICAgcmVjb3JkLiRba2V5SW5kZXhdID0gc3ViUmVjb3JkO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5yZWNvcmRzLnB1c2gocmVjb3JkKTtcbiAgfVxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtleXM6IHRoaXMua2V5cyxcbiAgICAgIHJlY29yZHM6IHRoaXMucmVjb3Jkc1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVJbmRleChcbiAga2V5cyxcbiAgZG9jcyxcbiAgeyBnZXRGbiA9IENvbmZpZy5nZXRGbiwgZmllbGROb3JtV2VpZ2h0ID0gQ29uZmlnLmZpZWxkTm9ybVdlaWdodCB9ID0ge31cbikge1xuICBjb25zdCBteUluZGV4ID0gbmV3IEZ1c2VJbmRleCh7IGdldEZuLCBmaWVsZE5vcm1XZWlnaHQgfSk7XG4gIG15SW5kZXguc2V0S2V5cyhrZXlzLm1hcChjcmVhdGVLZXkpKTtcbiAgbXlJbmRleC5zZXRTb3VyY2VzKGRvY3MpO1xuICBteUluZGV4LmNyZWF0ZSgpO1xuICByZXR1cm4gbXlJbmRleFxufVxuXG5mdW5jdGlvbiBwYXJzZUluZGV4KFxuICBkYXRhLFxuICB7IGdldEZuID0gQ29uZmlnLmdldEZuLCBmaWVsZE5vcm1XZWlnaHQgPSBDb25maWcuZmllbGROb3JtV2VpZ2h0IH0gPSB7fVxuKSB7XG4gIGNvbnN0IHsga2V5cywgcmVjb3JkcyB9ID0gZGF0YTtcbiAgY29uc3QgbXlJbmRleCA9IG5ldyBGdXNlSW5kZXgoeyBnZXRGbiwgZmllbGROb3JtV2VpZ2h0IH0pO1xuICBteUluZGV4LnNldEtleXMoa2V5cyk7XG4gIG15SW5kZXguc2V0SW5kZXhSZWNvcmRzKHJlY29yZHMpO1xuICByZXR1cm4gbXlJbmRleFxufVxuXG5mdW5jdGlvbiBjb21wdXRlU2NvcmUkMShcbiAgcGF0dGVybixcbiAge1xuICAgIGVycm9ycyA9IDAsXG4gICAgY3VycmVudExvY2F0aW9uID0gMCxcbiAgICBleHBlY3RlZExvY2F0aW9uID0gMCxcbiAgICBkaXN0YW5jZSA9IENvbmZpZy5kaXN0YW5jZSxcbiAgICBpZ25vcmVMb2NhdGlvbiA9IENvbmZpZy5pZ25vcmVMb2NhdGlvblxuICB9ID0ge31cbikge1xuICBjb25zdCBhY2N1cmFjeSA9IGVycm9ycyAvIHBhdHRlcm4ubGVuZ3RoO1xuXG4gIGlmIChpZ25vcmVMb2NhdGlvbikge1xuICAgIHJldHVybiBhY2N1cmFjeVxuICB9XG5cbiAgY29uc3QgcHJveGltaXR5ID0gTWF0aC5hYnMoZXhwZWN0ZWRMb2NhdGlvbiAtIGN1cnJlbnRMb2NhdGlvbik7XG5cbiAgaWYgKCFkaXN0YW5jZSkge1xuICAgIC8vIERvZGdlIGRpdmlkZSBieSB6ZXJvIGVycm9yLlxuICAgIHJldHVybiBwcm94aW1pdHkgPyAxLjAgOiBhY2N1cmFjeVxuICB9XG5cbiAgcmV0dXJuIGFjY3VyYWN5ICsgcHJveGltaXR5IC8gZGlzdGFuY2Vcbn1cblxuZnVuY3Rpb24gY29udmVydE1hc2tUb0luZGljZXMoXG4gIG1hdGNobWFzayA9IFtdLFxuICBtaW5NYXRjaENoYXJMZW5ndGggPSBDb25maWcubWluTWF0Y2hDaGFyTGVuZ3RoXG4pIHtcbiAgbGV0IGluZGljZXMgPSBbXTtcbiAgbGV0IHN0YXJ0ID0gLTE7XG4gIGxldCBlbmQgPSAtMTtcbiAgbGV0IGkgPSAwO1xuXG4gIGZvciAobGV0IGxlbiA9IG1hdGNobWFzay5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgIGxldCBtYXRjaCA9IG1hdGNobWFza1tpXTtcbiAgICBpZiAobWF0Y2ggJiYgc3RhcnQgPT09IC0xKSB7XG4gICAgICBzdGFydCA9IGk7XG4gICAgfSBlbHNlIGlmICghbWF0Y2ggJiYgc3RhcnQgIT09IC0xKSB7XG4gICAgICBlbmQgPSBpIC0gMTtcbiAgICAgIGlmIChlbmQgLSBzdGFydCArIDEgPj0gbWluTWF0Y2hDaGFyTGVuZ3RoKSB7XG4gICAgICAgIGluZGljZXMucHVzaChbc3RhcnQsIGVuZF0pO1xuICAgICAgfVxuICAgICAgc3RhcnQgPSAtMTtcbiAgICB9XG4gIH1cblxuICAvLyAoaS0xIC0gc3RhcnQpICsgMSA9PiBpIC0gc3RhcnRcbiAgaWYgKG1hdGNobWFza1tpIC0gMV0gJiYgaSAtIHN0YXJ0ID49IG1pbk1hdGNoQ2hhckxlbmd0aCkge1xuICAgIGluZGljZXMucHVzaChbc3RhcnQsIGkgLSAxXSk7XG4gIH1cblxuICByZXR1cm4gaW5kaWNlc1xufVxuXG4vLyBNYWNoaW5lIHdvcmQgc2l6ZVxuY29uc3QgTUFYX0JJVFMgPSAzMjtcblxuZnVuY3Rpb24gc2VhcmNoKFxuICB0ZXh0LFxuICBwYXR0ZXJuLFxuICBwYXR0ZXJuQWxwaGFiZXQsXG4gIHtcbiAgICBsb2NhdGlvbiA9IENvbmZpZy5sb2NhdGlvbixcbiAgICBkaXN0YW5jZSA9IENvbmZpZy5kaXN0YW5jZSxcbiAgICB0aHJlc2hvbGQgPSBDb25maWcudGhyZXNob2xkLFxuICAgIGZpbmRBbGxNYXRjaGVzID0gQ29uZmlnLmZpbmRBbGxNYXRjaGVzLFxuICAgIG1pbk1hdGNoQ2hhckxlbmd0aCA9IENvbmZpZy5taW5NYXRjaENoYXJMZW5ndGgsXG4gICAgaW5jbHVkZU1hdGNoZXMgPSBDb25maWcuaW5jbHVkZU1hdGNoZXMsXG4gICAgaWdub3JlTG9jYXRpb24gPSBDb25maWcuaWdub3JlTG9jYXRpb25cbiAgfSA9IHt9XG4pIHtcbiAgaWYgKHBhdHRlcm4ubGVuZ3RoID4gTUFYX0JJVFMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoUEFUVEVSTl9MRU5HVEhfVE9PX0xBUkdFKE1BWF9CSVRTKSlcbiAgfVxuXG4gIGNvbnN0IHBhdHRlcm5MZW4gPSBwYXR0ZXJuLmxlbmd0aDtcbiAgLy8gU2V0IHN0YXJ0aW5nIGxvY2F0aW9uIGF0IGJlZ2lubmluZyB0ZXh0IGFuZCBpbml0aWFsaXplIHRoZSBhbHBoYWJldC5cbiAgY29uc3QgdGV4dExlbiA9IHRleHQubGVuZ3RoO1xuICAvLyBIYW5kbGUgdGhlIGNhc2Ugd2hlbiBsb2NhdGlvbiA+IHRleHQubGVuZ3RoXG4gIGNvbnN0IGV4cGVjdGVkTG9jYXRpb24gPSBNYXRoLm1heCgwLCBNYXRoLm1pbihsb2NhdGlvbiwgdGV4dExlbikpO1xuICAvLyBIaWdoZXN0IHNjb3JlIGJleW9uZCB3aGljaCB3ZSBnaXZlIHVwLlxuICBsZXQgY3VycmVudFRocmVzaG9sZCA9IHRocmVzaG9sZDtcbiAgLy8gSXMgdGhlcmUgYSBuZWFyYnkgZXhhY3QgbWF0Y2g/IChzcGVlZHVwKVxuICBsZXQgYmVzdExvY2F0aW9uID0gZXhwZWN0ZWRMb2NhdGlvbjtcblxuICAvLyBQZXJmb3JtYW5jZTogb25seSBjb21wdXRlciBtYXRjaGVzIHdoZW4gdGhlIG1pbk1hdGNoQ2hhckxlbmd0aCA+IDFcbiAgLy8gT1IgaWYgYGluY2x1ZGVNYXRjaGVzYCBpcyB0cnVlLlxuICBjb25zdCBjb21wdXRlTWF0Y2hlcyA9IG1pbk1hdGNoQ2hhckxlbmd0aCA+IDEgfHwgaW5jbHVkZU1hdGNoZXM7XG4gIC8vIEEgbWFzayBvZiB0aGUgbWF0Y2hlcywgdXNlZCBmb3IgYnVpbGRpbmcgdGhlIGluZGljZXNcbiAgY29uc3QgbWF0Y2hNYXNrID0gY29tcHV0ZU1hdGNoZXMgPyBBcnJheSh0ZXh0TGVuKSA6IFtdO1xuXG4gIGxldCBpbmRleDtcblxuICAvLyBHZXQgYWxsIGV4YWN0IG1hdGNoZXMsIGhlcmUgZm9yIHNwZWVkIHVwXG4gIHdoaWxlICgoaW5kZXggPSB0ZXh0LmluZGV4T2YocGF0dGVybiwgYmVzdExvY2F0aW9uKSkgPiAtMSkge1xuICAgIGxldCBzY29yZSA9IGNvbXB1dGVTY29yZSQxKHBhdHRlcm4sIHtcbiAgICAgIGN1cnJlbnRMb2NhdGlvbjogaW5kZXgsXG4gICAgICBleHBlY3RlZExvY2F0aW9uLFxuICAgICAgZGlzdGFuY2UsXG4gICAgICBpZ25vcmVMb2NhdGlvblxuICAgIH0pO1xuXG4gICAgY3VycmVudFRocmVzaG9sZCA9IE1hdGgubWluKHNjb3JlLCBjdXJyZW50VGhyZXNob2xkKTtcbiAgICBiZXN0TG9jYXRpb24gPSBpbmRleCArIHBhdHRlcm5MZW47XG5cbiAgICBpZiAoY29tcHV0ZU1hdGNoZXMpIHtcbiAgICAgIGxldCBpID0gMDtcbiAgICAgIHdoaWxlIChpIDwgcGF0dGVybkxlbikge1xuICAgICAgICBtYXRjaE1hc2tbaW5kZXggKyBpXSA9IDE7XG4gICAgICAgIGkgKz0gMTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBSZXNldCB0aGUgYmVzdCBsb2NhdGlvblxuICBiZXN0TG9jYXRpb24gPSAtMTtcblxuICBsZXQgbGFzdEJpdEFyciA9IFtdO1xuICBsZXQgZmluYWxTY29yZSA9IDE7XG4gIGxldCBiaW5NYXggPSBwYXR0ZXJuTGVuICsgdGV4dExlbjtcblxuICBjb25zdCBtYXNrID0gMSA8PCAocGF0dGVybkxlbiAtIDEpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0dGVybkxlbjsgaSArPSAxKSB7XG4gICAgLy8gU2NhbiBmb3IgdGhlIGJlc3QgbWF0Y2g7IGVhY2ggaXRlcmF0aW9uIGFsbG93cyBmb3Igb25lIG1vcmUgZXJyb3IuXG4gICAgLy8gUnVuIGEgYmluYXJ5IHNlYXJjaCB0byBkZXRlcm1pbmUgaG93IGZhciBmcm9tIHRoZSBtYXRjaCBsb2NhdGlvbiB3ZSBjYW4gc3RyYXlcbiAgICAvLyBhdCB0aGlzIGVycm9yIGxldmVsLlxuICAgIGxldCBiaW5NaW4gPSAwO1xuICAgIGxldCBiaW5NaWQgPSBiaW5NYXg7XG5cbiAgICB3aGlsZSAoYmluTWluIDwgYmluTWlkKSB7XG4gICAgICBjb25zdCBzY29yZSA9IGNvbXB1dGVTY29yZSQxKHBhdHRlcm4sIHtcbiAgICAgICAgZXJyb3JzOiBpLFxuICAgICAgICBjdXJyZW50TG9jYXRpb246IGV4cGVjdGVkTG9jYXRpb24gKyBiaW5NaWQsXG4gICAgICAgIGV4cGVjdGVkTG9jYXRpb24sXG4gICAgICAgIGRpc3RhbmNlLFxuICAgICAgICBpZ25vcmVMb2NhdGlvblxuICAgICAgfSk7XG5cbiAgICAgIGlmIChzY29yZSA8PSBjdXJyZW50VGhyZXNob2xkKSB7XG4gICAgICAgIGJpbk1pbiA9IGJpbk1pZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJpbk1heCA9IGJpbk1pZDtcbiAgICAgIH1cblxuICAgICAgYmluTWlkID0gTWF0aC5mbG9vcigoYmluTWF4IC0gYmluTWluKSAvIDIgKyBiaW5NaW4pO1xuICAgIH1cblxuICAgIC8vIFVzZSB0aGUgcmVzdWx0IGZyb20gdGhpcyBpdGVyYXRpb24gYXMgdGhlIG1heGltdW0gZm9yIHRoZSBuZXh0LlxuICAgIGJpbk1heCA9IGJpbk1pZDtcblxuICAgIGxldCBzdGFydCA9IE1hdGgubWF4KDEsIGV4cGVjdGVkTG9jYXRpb24gLSBiaW5NaWQgKyAxKTtcbiAgICBsZXQgZmluaXNoID0gZmluZEFsbE1hdGNoZXNcbiAgICAgID8gdGV4dExlblxuICAgICAgOiBNYXRoLm1pbihleHBlY3RlZExvY2F0aW9uICsgYmluTWlkLCB0ZXh0TGVuKSArIHBhdHRlcm5MZW47XG5cbiAgICAvLyBJbml0aWFsaXplIHRoZSBiaXQgYXJyYXlcbiAgICBsZXQgYml0QXJyID0gQXJyYXkoZmluaXNoICsgMik7XG5cbiAgICBiaXRBcnJbZmluaXNoICsgMV0gPSAoMSA8PCBpKSAtIDE7XG5cbiAgICBmb3IgKGxldCBqID0gZmluaXNoOyBqID49IHN0YXJ0OyBqIC09IDEpIHtcbiAgICAgIGxldCBjdXJyZW50TG9jYXRpb24gPSBqIC0gMTtcbiAgICAgIGxldCBjaGFyTWF0Y2ggPSBwYXR0ZXJuQWxwaGFiZXRbdGV4dC5jaGFyQXQoY3VycmVudExvY2F0aW9uKV07XG5cbiAgICAgIGlmIChjb21wdXRlTWF0Y2hlcykge1xuICAgICAgICAvLyBTcGVlZCB1cDogcXVpY2sgYm9vbCB0byBpbnQgY29udmVyc2lvbiAoaS5lLCBgY2hhck1hdGNoID8gMSA6IDBgKVxuICAgICAgICBtYXRjaE1hc2tbY3VycmVudExvY2F0aW9uXSA9ICshIWNoYXJNYXRjaDtcbiAgICAgIH1cblxuICAgICAgLy8gRmlyc3QgcGFzczogZXhhY3QgbWF0Y2hcbiAgICAgIGJpdEFycltqXSA9ICgoYml0QXJyW2ogKyAxXSA8PCAxKSB8IDEpICYgY2hhck1hdGNoO1xuXG4gICAgICAvLyBTdWJzZXF1ZW50IHBhc3NlczogZnV6enkgbWF0Y2hcbiAgICAgIGlmIChpKSB7XG4gICAgICAgIGJpdEFycltqXSB8PVxuICAgICAgICAgICgobGFzdEJpdEFycltqICsgMV0gfCBsYXN0Qml0QXJyW2pdKSA8PCAxKSB8IDEgfCBsYXN0Qml0QXJyW2ogKyAxXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGJpdEFycltqXSAmIG1hc2spIHtcbiAgICAgICAgZmluYWxTY29yZSA9IGNvbXB1dGVTY29yZSQxKHBhdHRlcm4sIHtcbiAgICAgICAgICBlcnJvcnM6IGksXG4gICAgICAgICAgY3VycmVudExvY2F0aW9uLFxuICAgICAgICAgIGV4cGVjdGVkTG9jYXRpb24sXG4gICAgICAgICAgZGlzdGFuY2UsXG4gICAgICAgICAgaWdub3JlTG9jYXRpb25cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gVGhpcyBtYXRjaCB3aWxsIGFsbW9zdCBjZXJ0YWlubHkgYmUgYmV0dGVyIHRoYW4gYW55IGV4aXN0aW5nIG1hdGNoLlxuICAgICAgICAvLyBCdXQgY2hlY2sgYW55d2F5LlxuICAgICAgICBpZiAoZmluYWxTY29yZSA8PSBjdXJyZW50VGhyZXNob2xkKSB7XG4gICAgICAgICAgLy8gSW5kZWVkIGl0IGlzXG4gICAgICAgICAgY3VycmVudFRocmVzaG9sZCA9IGZpbmFsU2NvcmU7XG4gICAgICAgICAgYmVzdExvY2F0aW9uID0gY3VycmVudExvY2F0aW9uO1xuXG4gICAgICAgICAgLy8gQWxyZWFkeSBwYXNzZWQgYGxvY2AsIGRvd25oaWxsIGZyb20gaGVyZSBvbiBpbi5cbiAgICAgICAgICBpZiAoYmVzdExvY2F0aW9uIDw9IGV4cGVjdGVkTG9jYXRpb24pIHtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gV2hlbiBwYXNzaW5nIGBiZXN0TG9jYXRpb25gLCBkb24ndCBleGNlZWQgb3VyIGN1cnJlbnQgZGlzdGFuY2UgZnJvbSBgZXhwZWN0ZWRMb2NhdGlvbmAuXG4gICAgICAgICAgc3RhcnQgPSBNYXRoLm1heCgxLCAyICogZXhwZWN0ZWRMb2NhdGlvbiAtIGJlc3RMb2NhdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBObyBob3BlIGZvciBhIChiZXR0ZXIpIG1hdGNoIGF0IGdyZWF0ZXIgZXJyb3IgbGV2ZWxzLlxuICAgIGNvbnN0IHNjb3JlID0gY29tcHV0ZVNjb3JlJDEocGF0dGVybiwge1xuICAgICAgZXJyb3JzOiBpICsgMSxcbiAgICAgIGN1cnJlbnRMb2NhdGlvbjogZXhwZWN0ZWRMb2NhdGlvbixcbiAgICAgIGV4cGVjdGVkTG9jYXRpb24sXG4gICAgICBkaXN0YW5jZSxcbiAgICAgIGlnbm9yZUxvY2F0aW9uXG4gICAgfSk7XG5cbiAgICBpZiAoc2NvcmUgPiBjdXJyZW50VGhyZXNob2xkKSB7XG4gICAgICBicmVha1xuICAgIH1cblxuICAgIGxhc3RCaXRBcnIgPSBiaXRBcnI7XG4gIH1cblxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgaXNNYXRjaDogYmVzdExvY2F0aW9uID49IDAsXG4gICAgLy8gQ291bnQgZXhhY3QgbWF0Y2hlcyAodGhvc2Ugd2l0aCBhIHNjb3JlIG9mIDApIHRvIGJlIFwiYWxtb3N0XCIgZXhhY3RcbiAgICBzY29yZTogTWF0aC5tYXgoMC4wMDEsIGZpbmFsU2NvcmUpXG4gIH07XG5cbiAgaWYgKGNvbXB1dGVNYXRjaGVzKSB7XG4gICAgY29uc3QgaW5kaWNlcyA9IGNvbnZlcnRNYXNrVG9JbmRpY2VzKG1hdGNoTWFzaywgbWluTWF0Y2hDaGFyTGVuZ3RoKTtcbiAgICBpZiAoIWluZGljZXMubGVuZ3RoKSB7XG4gICAgICByZXN1bHQuaXNNYXRjaCA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoaW5jbHVkZU1hdGNoZXMpIHtcbiAgICAgIHJlc3VsdC5pbmRpY2VzID0gaW5kaWNlcztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBhdHRlcm5BbHBoYWJldChwYXR0ZXJuKSB7XG4gIGxldCBtYXNrID0ge307XG5cbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHBhdHRlcm4ubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICBjb25zdCBjaGFyID0gcGF0dGVybi5jaGFyQXQoaSk7XG4gICAgbWFza1tjaGFyXSA9IChtYXNrW2NoYXJdIHx8IDApIHwgKDEgPDwgKGxlbiAtIGkgLSAxKSk7XG4gIH1cblxuICByZXR1cm4gbWFza1xufVxuXG5jbGFzcyBCaXRhcFNlYXJjaCB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHBhdHRlcm4sXG4gICAge1xuICAgICAgbG9jYXRpb24gPSBDb25maWcubG9jYXRpb24sXG4gICAgICB0aHJlc2hvbGQgPSBDb25maWcudGhyZXNob2xkLFxuICAgICAgZGlzdGFuY2UgPSBDb25maWcuZGlzdGFuY2UsXG4gICAgICBpbmNsdWRlTWF0Y2hlcyA9IENvbmZpZy5pbmNsdWRlTWF0Y2hlcyxcbiAgICAgIGZpbmRBbGxNYXRjaGVzID0gQ29uZmlnLmZpbmRBbGxNYXRjaGVzLFxuICAgICAgbWluTWF0Y2hDaGFyTGVuZ3RoID0gQ29uZmlnLm1pbk1hdGNoQ2hhckxlbmd0aCxcbiAgICAgIGlzQ2FzZVNlbnNpdGl2ZSA9IENvbmZpZy5pc0Nhc2VTZW5zaXRpdmUsXG4gICAgICBpZ25vcmVMb2NhdGlvbiA9IENvbmZpZy5pZ25vcmVMb2NhdGlvblxuICAgIH0gPSB7fVxuICApIHtcbiAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICBsb2NhdGlvbixcbiAgICAgIHRocmVzaG9sZCxcbiAgICAgIGRpc3RhbmNlLFxuICAgICAgaW5jbHVkZU1hdGNoZXMsXG4gICAgICBmaW5kQWxsTWF0Y2hlcyxcbiAgICAgIG1pbk1hdGNoQ2hhckxlbmd0aCxcbiAgICAgIGlzQ2FzZVNlbnNpdGl2ZSxcbiAgICAgIGlnbm9yZUxvY2F0aW9uXG4gICAgfTtcblxuICAgIHRoaXMucGF0dGVybiA9IGlzQ2FzZVNlbnNpdGl2ZSA/IHBhdHRlcm4gOiBwYXR0ZXJuLnRvTG93ZXJDYXNlKCk7XG5cbiAgICB0aGlzLmNodW5rcyA9IFtdO1xuXG4gICAgaWYgKCF0aGlzLnBhdHRlcm4ubGVuZ3RoKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBhZGRDaHVuayA9IChwYXR0ZXJuLCBzdGFydEluZGV4KSA9PiB7XG4gICAgICB0aGlzLmNodW5rcy5wdXNoKHtcbiAgICAgICAgcGF0dGVybixcbiAgICAgICAgYWxwaGFiZXQ6IGNyZWF0ZVBhdHRlcm5BbHBoYWJldChwYXR0ZXJuKSxcbiAgICAgICAgc3RhcnRJbmRleFxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGNvbnN0IGxlbiA9IHRoaXMucGF0dGVybi5sZW5ndGg7XG5cbiAgICBpZiAobGVuID4gTUFYX0JJVFMpIHtcbiAgICAgIGxldCBpID0gMDtcbiAgICAgIGNvbnN0IHJlbWFpbmRlciA9IGxlbiAlIE1BWF9CSVRTO1xuICAgICAgY29uc3QgZW5kID0gbGVuIC0gcmVtYWluZGVyO1xuXG4gICAgICB3aGlsZSAoaSA8IGVuZCkge1xuICAgICAgICBhZGRDaHVuayh0aGlzLnBhdHRlcm4uc3Vic3RyKGksIE1BWF9CSVRTKSwgaSk7XG4gICAgICAgIGkgKz0gTUFYX0JJVFM7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZW1haW5kZXIpIHtcbiAgICAgICAgY29uc3Qgc3RhcnRJbmRleCA9IGxlbiAtIE1BWF9CSVRTO1xuICAgICAgICBhZGRDaHVuayh0aGlzLnBhdHRlcm4uc3Vic3RyKHN0YXJ0SW5kZXgpLCBzdGFydEluZGV4KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYWRkQ2h1bmsodGhpcy5wYXR0ZXJuLCAwKTtcbiAgICB9XG4gIH1cblxuICBzZWFyY2hJbih0ZXh0KSB7XG4gICAgY29uc3QgeyBpc0Nhc2VTZW5zaXRpdmUsIGluY2x1ZGVNYXRjaGVzIH0gPSB0aGlzLm9wdGlvbnM7XG5cbiAgICBpZiAoIWlzQ2FzZVNlbnNpdGl2ZSkge1xuICAgICAgdGV4dCA9IHRleHQudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICAvLyBFeGFjdCBtYXRjaFxuICAgIGlmICh0aGlzLnBhdHRlcm4gPT09IHRleHQpIHtcbiAgICAgIGxldCByZXN1bHQgPSB7XG4gICAgICAgIGlzTWF0Y2g6IHRydWUsXG4gICAgICAgIHNjb3JlOiAwXG4gICAgICB9O1xuXG4gICAgICBpZiAoaW5jbHVkZU1hdGNoZXMpIHtcbiAgICAgICAgcmVzdWx0LmluZGljZXMgPSBbWzAsIHRleHQubGVuZ3RoIC0gMV1dO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfVxuXG4gICAgLy8gT3RoZXJ3aXNlLCB1c2UgQml0YXAgYWxnb3JpdGhtXG4gICAgY29uc3Qge1xuICAgICAgbG9jYXRpb24sXG4gICAgICBkaXN0YW5jZSxcbiAgICAgIHRocmVzaG9sZCxcbiAgICAgIGZpbmRBbGxNYXRjaGVzLFxuICAgICAgbWluTWF0Y2hDaGFyTGVuZ3RoLFxuICAgICAgaWdub3JlTG9jYXRpb25cbiAgICB9ID0gdGhpcy5vcHRpb25zO1xuXG4gICAgbGV0IGFsbEluZGljZXMgPSBbXTtcbiAgICBsZXQgdG90YWxTY29yZSA9IDA7XG4gICAgbGV0IGhhc01hdGNoZXMgPSBmYWxzZTtcblxuICAgIHRoaXMuY2h1bmtzLmZvckVhY2goKHsgcGF0dGVybiwgYWxwaGFiZXQsIHN0YXJ0SW5kZXggfSkgPT4ge1xuICAgICAgY29uc3QgeyBpc01hdGNoLCBzY29yZSwgaW5kaWNlcyB9ID0gc2VhcmNoKHRleHQsIHBhdHRlcm4sIGFscGhhYmV0LCB7XG4gICAgICAgIGxvY2F0aW9uOiBsb2NhdGlvbiArIHN0YXJ0SW5kZXgsXG4gICAgICAgIGRpc3RhbmNlLFxuICAgICAgICB0aHJlc2hvbGQsXG4gICAgICAgIGZpbmRBbGxNYXRjaGVzLFxuICAgICAgICBtaW5NYXRjaENoYXJMZW5ndGgsXG4gICAgICAgIGluY2x1ZGVNYXRjaGVzLFxuICAgICAgICBpZ25vcmVMb2NhdGlvblxuICAgICAgfSk7XG5cbiAgICAgIGlmIChpc01hdGNoKSB7XG4gICAgICAgIGhhc01hdGNoZXMgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICB0b3RhbFNjb3JlICs9IHNjb3JlO1xuXG4gICAgICBpZiAoaXNNYXRjaCAmJiBpbmRpY2VzKSB7XG4gICAgICAgIGFsbEluZGljZXMgPSBbLi4uYWxsSW5kaWNlcywgLi4uaW5kaWNlc107XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgaXNNYXRjaDogaGFzTWF0Y2hlcyxcbiAgICAgIHNjb3JlOiBoYXNNYXRjaGVzID8gdG90YWxTY29yZSAvIHRoaXMuY2h1bmtzLmxlbmd0aCA6IDFcbiAgICB9O1xuXG4gICAgaWYgKGhhc01hdGNoZXMgJiYgaW5jbHVkZU1hdGNoZXMpIHtcbiAgICAgIHJlc3VsdC5pbmRpY2VzID0gYWxsSW5kaWNlcztcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cbn1cblxuY2xhc3MgQmFzZU1hdGNoIHtcbiAgY29uc3RydWN0b3IocGF0dGVybikge1xuICAgIHRoaXMucGF0dGVybiA9IHBhdHRlcm47XG4gIH1cbiAgc3RhdGljIGlzTXVsdGlNYXRjaChwYXR0ZXJuKSB7XG4gICAgcmV0dXJuIGdldE1hdGNoKHBhdHRlcm4sIHRoaXMubXVsdGlSZWdleClcbiAgfVxuICBzdGF0aWMgaXNTaW5nbGVNYXRjaChwYXR0ZXJuKSB7XG4gICAgcmV0dXJuIGdldE1hdGNoKHBhdHRlcm4sIHRoaXMuc2luZ2xlUmVnZXgpXG4gIH1cbiAgc2VhcmNoKC8qdGV4dCovKSB7fVxufVxuXG5mdW5jdGlvbiBnZXRNYXRjaChwYXR0ZXJuLCBleHApIHtcbiAgY29uc3QgbWF0Y2hlcyA9IHBhdHRlcm4ubWF0Y2goZXhwKTtcbiAgcmV0dXJuIG1hdGNoZXMgPyBtYXRjaGVzWzFdIDogbnVsbFxufVxuXG4vLyBUb2tlbjogJ2ZpbGVcblxuY2xhc3MgRXhhY3RNYXRjaCBleHRlbmRzIEJhc2VNYXRjaCB7XG4gIGNvbnN0cnVjdG9yKHBhdHRlcm4pIHtcbiAgICBzdXBlcihwYXR0ZXJuKTtcbiAgfVxuICBzdGF0aWMgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuICdleGFjdCdcbiAgfVxuICBzdGF0aWMgZ2V0IG11bHRpUmVnZXgoKSB7XG4gICAgcmV0dXJuIC9ePVwiKC4qKVwiJC9cbiAgfVxuICBzdGF0aWMgZ2V0IHNpbmdsZVJlZ2V4KCkge1xuICAgIHJldHVybiAvXj0oLiopJC9cbiAgfVxuICBzZWFyY2godGV4dCkge1xuICAgIGNvbnN0IGlzTWF0Y2ggPSB0ZXh0ID09PSB0aGlzLnBhdHRlcm47XG5cbiAgICByZXR1cm4ge1xuICAgICAgaXNNYXRjaCxcbiAgICAgIHNjb3JlOiBpc01hdGNoID8gMCA6IDEsXG4gICAgICBpbmRpY2VzOiBbMCwgdGhpcy5wYXR0ZXJuLmxlbmd0aCAtIDFdXG4gICAgfVxuICB9XG59XG5cbi8vIFRva2VuOiAhZmlyZVxuXG5jbGFzcyBJbnZlcnNlRXhhY3RNYXRjaCBleHRlbmRzIEJhc2VNYXRjaCB7XG4gIGNvbnN0cnVjdG9yKHBhdHRlcm4pIHtcbiAgICBzdXBlcihwYXR0ZXJuKTtcbiAgfVxuICBzdGF0aWMgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuICdpbnZlcnNlLWV4YWN0J1xuICB9XG4gIHN0YXRpYyBnZXQgbXVsdGlSZWdleCgpIHtcbiAgICByZXR1cm4gL14hXCIoLiopXCIkL1xuICB9XG4gIHN0YXRpYyBnZXQgc2luZ2xlUmVnZXgoKSB7XG4gICAgcmV0dXJuIC9eISguKikkL1xuICB9XG4gIHNlYXJjaCh0ZXh0KSB7XG4gICAgY29uc3QgaW5kZXggPSB0ZXh0LmluZGV4T2YodGhpcy5wYXR0ZXJuKTtcbiAgICBjb25zdCBpc01hdGNoID0gaW5kZXggPT09IC0xO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGlzTWF0Y2gsXG4gICAgICBzY29yZTogaXNNYXRjaCA/IDAgOiAxLFxuICAgICAgaW5kaWNlczogWzAsIHRleHQubGVuZ3RoIC0gMV1cbiAgICB9XG4gIH1cbn1cblxuLy8gVG9rZW46IF5maWxlXG5cbmNsYXNzIFByZWZpeEV4YWN0TWF0Y2ggZXh0ZW5kcyBCYXNlTWF0Y2gge1xuICBjb25zdHJ1Y3RvcihwYXR0ZXJuKSB7XG4gICAgc3VwZXIocGF0dGVybik7XG4gIH1cbiAgc3RhdGljIGdldCB0eXBlKCkge1xuICAgIHJldHVybiAncHJlZml4LWV4YWN0J1xuICB9XG4gIHN0YXRpYyBnZXQgbXVsdGlSZWdleCgpIHtcbiAgICByZXR1cm4gL15cXF5cIiguKilcIiQvXG4gIH1cbiAgc3RhdGljIGdldCBzaW5nbGVSZWdleCgpIHtcbiAgICByZXR1cm4gL15cXF4oLiopJC9cbiAgfVxuICBzZWFyY2godGV4dCkge1xuICAgIGNvbnN0IGlzTWF0Y2ggPSB0ZXh0LnN0YXJ0c1dpdGgodGhpcy5wYXR0ZXJuKTtcblxuICAgIHJldHVybiB7XG4gICAgICBpc01hdGNoLFxuICAgICAgc2NvcmU6IGlzTWF0Y2ggPyAwIDogMSxcbiAgICAgIGluZGljZXM6IFswLCB0aGlzLnBhdHRlcm4ubGVuZ3RoIC0gMV1cbiAgICB9XG4gIH1cbn1cblxuLy8gVG9rZW46ICFeZmlyZVxuXG5jbGFzcyBJbnZlcnNlUHJlZml4RXhhY3RNYXRjaCBleHRlbmRzIEJhc2VNYXRjaCB7XG4gIGNvbnN0cnVjdG9yKHBhdHRlcm4pIHtcbiAgICBzdXBlcihwYXR0ZXJuKTtcbiAgfVxuICBzdGF0aWMgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuICdpbnZlcnNlLXByZWZpeC1leGFjdCdcbiAgfVxuICBzdGF0aWMgZ2V0IG11bHRpUmVnZXgoKSB7XG4gICAgcmV0dXJuIC9eIVxcXlwiKC4qKVwiJC9cbiAgfVxuICBzdGF0aWMgZ2V0IHNpbmdsZVJlZ2V4KCkge1xuICAgIHJldHVybiAvXiFcXF4oLiopJC9cbiAgfVxuICBzZWFyY2godGV4dCkge1xuICAgIGNvbnN0IGlzTWF0Y2ggPSAhdGV4dC5zdGFydHNXaXRoKHRoaXMucGF0dGVybik7XG5cbiAgICByZXR1cm4ge1xuICAgICAgaXNNYXRjaCxcbiAgICAgIHNjb3JlOiBpc01hdGNoID8gMCA6IDEsXG4gICAgICBpbmRpY2VzOiBbMCwgdGV4dC5sZW5ndGggLSAxXVxuICAgIH1cbiAgfVxufVxuXG4vLyBUb2tlbjogLmZpbGUkXG5cbmNsYXNzIFN1ZmZpeEV4YWN0TWF0Y2ggZXh0ZW5kcyBCYXNlTWF0Y2gge1xuICBjb25zdHJ1Y3RvcihwYXR0ZXJuKSB7XG4gICAgc3VwZXIocGF0dGVybik7XG4gIH1cbiAgc3RhdGljIGdldCB0eXBlKCkge1xuICAgIHJldHVybiAnc3VmZml4LWV4YWN0J1xuICB9XG4gIHN0YXRpYyBnZXQgbXVsdGlSZWdleCgpIHtcbiAgICByZXR1cm4gL15cIiguKilcIlxcJCQvXG4gIH1cbiAgc3RhdGljIGdldCBzaW5nbGVSZWdleCgpIHtcbiAgICByZXR1cm4gL14oLiopXFwkJC9cbiAgfVxuICBzZWFyY2godGV4dCkge1xuICAgIGNvbnN0IGlzTWF0Y2ggPSB0ZXh0LmVuZHNXaXRoKHRoaXMucGF0dGVybik7XG5cbiAgICByZXR1cm4ge1xuICAgICAgaXNNYXRjaCxcbiAgICAgIHNjb3JlOiBpc01hdGNoID8gMCA6IDEsXG4gICAgICBpbmRpY2VzOiBbdGV4dC5sZW5ndGggLSB0aGlzLnBhdHRlcm4ubGVuZ3RoLCB0ZXh0Lmxlbmd0aCAtIDFdXG4gICAgfVxuICB9XG59XG5cbi8vIFRva2VuOiAhLmZpbGUkXG5cbmNsYXNzIEludmVyc2VTdWZmaXhFeGFjdE1hdGNoIGV4dGVuZHMgQmFzZU1hdGNoIHtcbiAgY29uc3RydWN0b3IocGF0dGVybikge1xuICAgIHN1cGVyKHBhdHRlcm4pO1xuICB9XG4gIHN0YXRpYyBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gJ2ludmVyc2Utc3VmZml4LWV4YWN0J1xuICB9XG4gIHN0YXRpYyBnZXQgbXVsdGlSZWdleCgpIHtcbiAgICByZXR1cm4gL14hXCIoLiopXCJcXCQkL1xuICB9XG4gIHN0YXRpYyBnZXQgc2luZ2xlUmVnZXgoKSB7XG4gICAgcmV0dXJuIC9eISguKilcXCQkL1xuICB9XG4gIHNlYXJjaCh0ZXh0KSB7XG4gICAgY29uc3QgaXNNYXRjaCA9ICF0ZXh0LmVuZHNXaXRoKHRoaXMucGF0dGVybik7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzTWF0Y2gsXG4gICAgICBzY29yZTogaXNNYXRjaCA/IDAgOiAxLFxuICAgICAgaW5kaWNlczogWzAsIHRleHQubGVuZ3RoIC0gMV1cbiAgICB9XG4gIH1cbn1cblxuY2xhc3MgRnV6enlNYXRjaCBleHRlbmRzIEJhc2VNYXRjaCB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHBhdHRlcm4sXG4gICAge1xuICAgICAgbG9jYXRpb24gPSBDb25maWcubG9jYXRpb24sXG4gICAgICB0aHJlc2hvbGQgPSBDb25maWcudGhyZXNob2xkLFxuICAgICAgZGlzdGFuY2UgPSBDb25maWcuZGlzdGFuY2UsXG4gICAgICBpbmNsdWRlTWF0Y2hlcyA9IENvbmZpZy5pbmNsdWRlTWF0Y2hlcyxcbiAgICAgIGZpbmRBbGxNYXRjaGVzID0gQ29uZmlnLmZpbmRBbGxNYXRjaGVzLFxuICAgICAgbWluTWF0Y2hDaGFyTGVuZ3RoID0gQ29uZmlnLm1pbk1hdGNoQ2hhckxlbmd0aCxcbiAgICAgIGlzQ2FzZVNlbnNpdGl2ZSA9IENvbmZpZy5pc0Nhc2VTZW5zaXRpdmUsXG4gICAgICBpZ25vcmVMb2NhdGlvbiA9IENvbmZpZy5pZ25vcmVMb2NhdGlvblxuICAgIH0gPSB7fVxuICApIHtcbiAgICBzdXBlcihwYXR0ZXJuKTtcbiAgICB0aGlzLl9iaXRhcFNlYXJjaCA9IG5ldyBCaXRhcFNlYXJjaChwYXR0ZXJuLCB7XG4gICAgICBsb2NhdGlvbixcbiAgICAgIHRocmVzaG9sZCxcbiAgICAgIGRpc3RhbmNlLFxuICAgICAgaW5jbHVkZU1hdGNoZXMsXG4gICAgICBmaW5kQWxsTWF0Y2hlcyxcbiAgICAgIG1pbk1hdGNoQ2hhckxlbmd0aCxcbiAgICAgIGlzQ2FzZVNlbnNpdGl2ZSxcbiAgICAgIGlnbm9yZUxvY2F0aW9uXG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGdldCB0eXBlKCkge1xuICAgIHJldHVybiAnZnV6enknXG4gIH1cbiAgc3RhdGljIGdldCBtdWx0aVJlZ2V4KCkge1xuICAgIHJldHVybiAvXlwiKC4qKVwiJC9cbiAgfVxuICBzdGF0aWMgZ2V0IHNpbmdsZVJlZ2V4KCkge1xuICAgIHJldHVybiAvXiguKikkL1xuICB9XG4gIHNlYXJjaCh0ZXh0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2JpdGFwU2VhcmNoLnNlYXJjaEluKHRleHQpXG4gIH1cbn1cblxuLy8gVG9rZW46ICdmaWxlXG5cbmNsYXNzIEluY2x1ZGVNYXRjaCBleHRlbmRzIEJhc2VNYXRjaCB7XG4gIGNvbnN0cnVjdG9yKHBhdHRlcm4pIHtcbiAgICBzdXBlcihwYXR0ZXJuKTtcbiAgfVxuICBzdGF0aWMgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuICdpbmNsdWRlJ1xuICB9XG4gIHN0YXRpYyBnZXQgbXVsdGlSZWdleCgpIHtcbiAgICByZXR1cm4gL14nXCIoLiopXCIkL1xuICB9XG4gIHN0YXRpYyBnZXQgc2luZ2xlUmVnZXgoKSB7XG4gICAgcmV0dXJuIC9eJyguKikkL1xuICB9XG4gIHNlYXJjaCh0ZXh0KSB7XG4gICAgbGV0IGxvY2F0aW9uID0gMDtcbiAgICBsZXQgaW5kZXg7XG5cbiAgICBjb25zdCBpbmRpY2VzID0gW107XG4gICAgY29uc3QgcGF0dGVybkxlbiA9IHRoaXMucGF0dGVybi5sZW5ndGg7XG5cbiAgICAvLyBHZXQgYWxsIGV4YWN0IG1hdGNoZXNcbiAgICB3aGlsZSAoKGluZGV4ID0gdGV4dC5pbmRleE9mKHRoaXMucGF0dGVybiwgbG9jYXRpb24pKSA+IC0xKSB7XG4gICAgICBsb2NhdGlvbiA9IGluZGV4ICsgcGF0dGVybkxlbjtcbiAgICAgIGluZGljZXMucHVzaChbaW5kZXgsIGxvY2F0aW9uIC0gMV0pO1xuICAgIH1cblxuICAgIGNvbnN0IGlzTWF0Y2ggPSAhIWluZGljZXMubGVuZ3RoO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGlzTWF0Y2gsXG4gICAgICBzY29yZTogaXNNYXRjaCA/IDAgOiAxLFxuICAgICAgaW5kaWNlc1xuICAgIH1cbiAgfVxufVxuXG4vLyDinZdPcmRlciBpcyBpbXBvcnRhbnQuIERPIE5PVCBDSEFOR0UuXG5jb25zdCBzZWFyY2hlcnMgPSBbXG4gIEV4YWN0TWF0Y2gsXG4gIEluY2x1ZGVNYXRjaCxcbiAgUHJlZml4RXhhY3RNYXRjaCxcbiAgSW52ZXJzZVByZWZpeEV4YWN0TWF0Y2gsXG4gIEludmVyc2VTdWZmaXhFeGFjdE1hdGNoLFxuICBTdWZmaXhFeGFjdE1hdGNoLFxuICBJbnZlcnNlRXhhY3RNYXRjaCxcbiAgRnV6enlNYXRjaFxuXTtcblxuY29uc3Qgc2VhcmNoZXJzTGVuID0gc2VhcmNoZXJzLmxlbmd0aDtcblxuLy8gUmVnZXggdG8gc3BsaXQgYnkgc3BhY2VzLCBidXQga2VlcCBhbnl0aGluZyBpbiBxdW90ZXMgdG9nZXRoZXJcbmNvbnN0IFNQQUNFX1JFID0gLyArKD89KD86W15cXFwiXSpcXFwiW15cXFwiXSpcXFwiKSpbXlxcXCJdKiQpLztcbmNvbnN0IE9SX1RPS0VOID0gJ3wnO1xuXG4vLyBSZXR1cm4gYSAyRCBhcnJheSByZXByZXNlbnRhdGlvbiBvZiB0aGUgcXVlcnksIGZvciBzaW1wbGVyIHBhcnNpbmcuXG4vLyBFeGFtcGxlOlxuLy8gXCJeY29yZSBnbyQgfCByYiQgfCBweSQgeHkkXCIgPT4gW1tcIl5jb3JlXCIsIFwiZ28kXCJdLCBbXCJyYiRcIl0sIFtcInB5JFwiLCBcInh5JFwiXV1cbmZ1bmN0aW9uIHBhcnNlUXVlcnkocGF0dGVybiwgb3B0aW9ucyA9IHt9KSB7XG4gIHJldHVybiBwYXR0ZXJuLnNwbGl0KE9SX1RPS0VOKS5tYXAoKGl0ZW0pID0+IHtcbiAgICBsZXQgcXVlcnkgPSBpdGVtXG4gICAgICAudHJpbSgpXG4gICAgICAuc3BsaXQoU1BBQ0VfUkUpXG4gICAgICAuZmlsdGVyKChpdGVtKSA9PiBpdGVtICYmICEhaXRlbS50cmltKCkpO1xuXG4gICAgbGV0IHJlc3VsdHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gcXVlcnkubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIGNvbnN0IHF1ZXJ5SXRlbSA9IHF1ZXJ5W2ldO1xuXG4gICAgICAvLyAxLiBIYW5kbGUgbXVsdGlwbGUgcXVlcnkgbWF0Y2ggKGkuZSwgb25jZSB0aGF0IGFyZSBxdW90ZWQsIGxpa2UgYFwiaGVsbG8gd29ybGRcImApXG4gICAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICAgIGxldCBpZHggPSAtMTtcbiAgICAgIHdoaWxlICghZm91bmQgJiYgKytpZHggPCBzZWFyY2hlcnNMZW4pIHtcbiAgICAgICAgY29uc3Qgc2VhcmNoZXIgPSBzZWFyY2hlcnNbaWR4XTtcbiAgICAgICAgbGV0IHRva2VuID0gc2VhcmNoZXIuaXNNdWx0aU1hdGNoKHF1ZXJ5SXRlbSk7XG4gICAgICAgIGlmICh0b2tlbikge1xuICAgICAgICAgIHJlc3VsdHMucHVzaChuZXcgc2VhcmNoZXIodG9rZW4sIG9wdGlvbnMpKTtcbiAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIuIEhhbmRsZSBzaW5nbGUgcXVlcnkgbWF0Y2hlcyAoaS5lLCBvbmNlIHRoYXQgYXJlICpub3QqIHF1b3RlZClcbiAgICAgIGlkeCA9IC0xO1xuICAgICAgd2hpbGUgKCsraWR4IDwgc2VhcmNoZXJzTGVuKSB7XG4gICAgICAgIGNvbnN0IHNlYXJjaGVyID0gc2VhcmNoZXJzW2lkeF07XG4gICAgICAgIGxldCB0b2tlbiA9IHNlYXJjaGVyLmlzU2luZ2xlTWF0Y2gocXVlcnlJdGVtKTtcbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKG5ldyBzZWFyY2hlcih0b2tlbiwgb3B0aW9ucykpO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0c1xuICB9KVxufVxuXG4vLyBUaGVzZSBleHRlbmRlZCBtYXRjaGVycyBjYW4gcmV0dXJuIGFuIGFycmF5IG9mIG1hdGNoZXMsIGFzIG9wcG9zZWRcbi8vIHRvIGEgc2luZ2wgbWF0Y2hcbmNvbnN0IE11bHRpTWF0Y2hTZXQgPSBuZXcgU2V0KFtGdXp6eU1hdGNoLnR5cGUsIEluY2x1ZGVNYXRjaC50eXBlXSk7XG5cbi8qKlxuICogQ29tbWFuZC1saWtlIHNlYXJjaGluZ1xuICogPT09PT09PT09PT09PT09PT09PT09PVxuICpcbiAqIEdpdmVuIG11bHRpcGxlIHNlYXJjaCB0ZXJtcyBkZWxpbWl0ZWQgYnkgc3BhY2VzLmUuZy4gYF5qc2NyaXB0IC5weXRob24kIHJ1YnkgIWphdmFgLFxuICogc2VhcmNoIGluIGEgZ2l2ZW4gdGV4dC5cbiAqXG4gKiBTZWFyY2ggc3ludGF4OlxuICpcbiAqIHwgVG9rZW4gICAgICAgfCBNYXRjaCB0eXBlICAgICAgICAgICAgICAgICB8IERlc2NyaXB0aW9uICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgLS0tLS0tLS0tLS0gfCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSB8IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIHxcbiAqIHwgYGpzY3JpcHRgICAgfCBmdXp6eS1tYXRjaCAgICAgICAgICAgICAgICB8IEl0ZW1zIHRoYXQgZnV6enkgbWF0Y2ggYGpzY3JpcHRgICAgICAgIHxcbiAqIHwgYD1zY2hlbWVgICAgfCBleGFjdC1tYXRjaCAgICAgICAgICAgICAgICB8IEl0ZW1zIHRoYXQgYXJlIGBzY2hlbWVgICAgICAgICAgICAgICAgIHxcbiAqIHwgYCdweXRob25gICAgfCBpbmNsdWRlLW1hdGNoICAgICAgICAgICAgICB8IEl0ZW1zIHRoYXQgaW5jbHVkZSBgcHl0aG9uYCAgICAgICAgICAgIHxcbiAqIHwgYCFydWJ5YCAgICAgfCBpbnZlcnNlLWV4YWN0LW1hdGNoICAgICAgICB8IEl0ZW1zIHRoYXQgZG8gbm90IGluY2x1ZGUgYHJ1YnlgICAgICAgIHxcbiAqIHwgYF5qYXZhYCAgICAgfCBwcmVmaXgtZXhhY3QtbWF0Y2ggICAgICAgICB8IEl0ZW1zIHRoYXQgc3RhcnQgd2l0aCBgamF2YWAgICAgICAgICAgIHxcbiAqIHwgYCFeZWFybGFuZ2AgfCBpbnZlcnNlLXByZWZpeC1leGFjdC1tYXRjaCB8IEl0ZW1zIHRoYXQgZG8gbm90IHN0YXJ0IHdpdGggYGVhcmxhbmdgIHxcbiAqIHwgYC5qcyRgICAgICAgfCBzdWZmaXgtZXhhY3QtbWF0Y2ggICAgICAgICB8IEl0ZW1zIHRoYXQgZW5kIHdpdGggYC5qc2AgICAgICAgICAgICAgIHxcbiAqIHwgYCEuZ28kYCAgICAgfCBpbnZlcnNlLXN1ZmZpeC1leGFjdC1tYXRjaCB8IEl0ZW1zIHRoYXQgZG8gbm90IGVuZCB3aXRoIGAuZ29gICAgICAgIHxcbiAqXG4gKiBBIHNpbmdsZSBwaXBlIGNoYXJhY3RlciBhY3RzIGFzIGFuIE9SIG9wZXJhdG9yLiBGb3IgZXhhbXBsZSwgdGhlIGZvbGxvd2luZ1xuICogcXVlcnkgbWF0Y2hlcyBlbnRyaWVzIHRoYXQgc3RhcnQgd2l0aCBgY29yZWAgYW5kIGVuZCB3aXRoIGVpdGhlcmBnb2AsIGByYmAsXG4gKiBvcmBweWAuXG4gKlxuICogYGBgXG4gKiBeY29yZSBnbyQgfCByYiQgfCBweSRcbiAqIGBgYFxuICovXG5jbGFzcyBFeHRlbmRlZFNlYXJjaCB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHBhdHRlcm4sXG4gICAge1xuICAgICAgaXNDYXNlU2Vuc2l0aXZlID0gQ29uZmlnLmlzQ2FzZVNlbnNpdGl2ZSxcbiAgICAgIGluY2x1ZGVNYXRjaGVzID0gQ29uZmlnLmluY2x1ZGVNYXRjaGVzLFxuICAgICAgbWluTWF0Y2hDaGFyTGVuZ3RoID0gQ29uZmlnLm1pbk1hdGNoQ2hhckxlbmd0aCxcbiAgICAgIGlnbm9yZUxvY2F0aW9uID0gQ29uZmlnLmlnbm9yZUxvY2F0aW9uLFxuICAgICAgZmluZEFsbE1hdGNoZXMgPSBDb25maWcuZmluZEFsbE1hdGNoZXMsXG4gICAgICBsb2NhdGlvbiA9IENvbmZpZy5sb2NhdGlvbixcbiAgICAgIHRocmVzaG9sZCA9IENvbmZpZy50aHJlc2hvbGQsXG4gICAgICBkaXN0YW5jZSA9IENvbmZpZy5kaXN0YW5jZVxuICAgIH0gPSB7fVxuICApIHtcbiAgICB0aGlzLnF1ZXJ5ID0gbnVsbDtcbiAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICBpc0Nhc2VTZW5zaXRpdmUsXG4gICAgICBpbmNsdWRlTWF0Y2hlcyxcbiAgICAgIG1pbk1hdGNoQ2hhckxlbmd0aCxcbiAgICAgIGZpbmRBbGxNYXRjaGVzLFxuICAgICAgaWdub3JlTG9jYXRpb24sXG4gICAgICBsb2NhdGlvbixcbiAgICAgIHRocmVzaG9sZCxcbiAgICAgIGRpc3RhbmNlXG4gICAgfTtcblxuICAgIHRoaXMucGF0dGVybiA9IGlzQ2FzZVNlbnNpdGl2ZSA/IHBhdHRlcm4gOiBwYXR0ZXJuLnRvTG93ZXJDYXNlKCk7XG4gICAgdGhpcy5xdWVyeSA9IHBhcnNlUXVlcnkodGhpcy5wYXR0ZXJuLCB0aGlzLm9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGNvbmRpdGlvbihfLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMudXNlRXh0ZW5kZWRTZWFyY2hcbiAgfVxuXG4gIHNlYXJjaEluKHRleHQpIHtcbiAgICBjb25zdCBxdWVyeSA9IHRoaXMucXVlcnk7XG5cbiAgICBpZiAoIXF1ZXJ5KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpc01hdGNoOiBmYWxzZSxcbiAgICAgICAgc2NvcmU6IDFcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCB7IGluY2x1ZGVNYXRjaGVzLCBpc0Nhc2VTZW5zaXRpdmUgfSA9IHRoaXMub3B0aW9ucztcblxuICAgIHRleHQgPSBpc0Nhc2VTZW5zaXRpdmUgPyB0ZXh0IDogdGV4dC50b0xvd2VyQ2FzZSgpO1xuXG4gICAgbGV0IG51bU1hdGNoZXMgPSAwO1xuICAgIGxldCBhbGxJbmRpY2VzID0gW107XG4gICAgbGV0IHRvdGFsU2NvcmUgPSAwO1xuXG4gICAgLy8gT1JzXG4gICAgZm9yIChsZXQgaSA9IDAsIHFMZW4gPSBxdWVyeS5sZW5ndGg7IGkgPCBxTGVuOyBpICs9IDEpIHtcbiAgICAgIGNvbnN0IHNlYXJjaGVycyA9IHF1ZXJ5W2ldO1xuXG4gICAgICAvLyBSZXNldCBpbmRpY2VzXG4gICAgICBhbGxJbmRpY2VzLmxlbmd0aCA9IDA7XG4gICAgICBudW1NYXRjaGVzID0gMDtcblxuICAgICAgLy8gQU5Ec1xuICAgICAgZm9yIChsZXQgaiA9IDAsIHBMZW4gPSBzZWFyY2hlcnMubGVuZ3RoOyBqIDwgcExlbjsgaiArPSAxKSB7XG4gICAgICAgIGNvbnN0IHNlYXJjaGVyID0gc2VhcmNoZXJzW2pdO1xuICAgICAgICBjb25zdCB7IGlzTWF0Y2gsIGluZGljZXMsIHNjb3JlIH0gPSBzZWFyY2hlci5zZWFyY2godGV4dCk7XG5cbiAgICAgICAgaWYgKGlzTWF0Y2gpIHtcbiAgICAgICAgICBudW1NYXRjaGVzICs9IDE7XG4gICAgICAgICAgdG90YWxTY29yZSArPSBzY29yZTtcbiAgICAgICAgICBpZiAoaW5jbHVkZU1hdGNoZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBzZWFyY2hlci5jb25zdHJ1Y3Rvci50eXBlO1xuICAgICAgICAgICAgaWYgKE11bHRpTWF0Y2hTZXQuaGFzKHR5cGUpKSB7XG4gICAgICAgICAgICAgIGFsbEluZGljZXMgPSBbLi4uYWxsSW5kaWNlcywgLi4uaW5kaWNlc107XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhbGxJbmRpY2VzLnB1c2goaW5kaWNlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRvdGFsU2NvcmUgPSAwO1xuICAgICAgICAgIG51bU1hdGNoZXMgPSAwO1xuICAgICAgICAgIGFsbEluZGljZXMubGVuZ3RoID0gMDtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIE9SIGNvbmRpdGlvbiwgc28gaWYgVFJVRSwgcmV0dXJuXG4gICAgICBpZiAobnVtTWF0Y2hlcykge1xuICAgICAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICAgIGlzTWF0Y2g6IHRydWUsXG4gICAgICAgICAgc2NvcmU6IHRvdGFsU2NvcmUgLyBudW1NYXRjaGVzXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGluY2x1ZGVNYXRjaGVzKSB7XG4gICAgICAgICAgcmVzdWx0LmluZGljZXMgPSBhbGxJbmRpY2VzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE5vdGhpbmcgd2FzIG1hdGNoZWRcbiAgICByZXR1cm4ge1xuICAgICAgaXNNYXRjaDogZmFsc2UsXG4gICAgICBzY29yZTogMVxuICAgIH1cbiAgfVxufVxuXG5jb25zdCByZWdpc3RlcmVkU2VhcmNoZXJzID0gW107XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyKC4uLmFyZ3MpIHtcbiAgcmVnaXN0ZXJlZFNlYXJjaGVycy5wdXNoKC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVTZWFyY2hlcihwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSByZWdpc3RlcmVkU2VhcmNoZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgbGV0IHNlYXJjaGVyQ2xhc3MgPSByZWdpc3RlcmVkU2VhcmNoZXJzW2ldO1xuICAgIGlmIChzZWFyY2hlckNsYXNzLmNvbmRpdGlvbihwYXR0ZXJuLCBvcHRpb25zKSkge1xuICAgICAgcmV0dXJuIG5ldyBzZWFyY2hlckNsYXNzKHBhdHRlcm4sIG9wdGlvbnMpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBCaXRhcFNlYXJjaChwYXR0ZXJuLCBvcHRpb25zKVxufVxuXG5jb25zdCBMb2dpY2FsT3BlcmF0b3IgPSB7XG4gIEFORDogJyRhbmQnLFxuICBPUjogJyRvcidcbn07XG5cbmNvbnN0IEtleVR5cGUgPSB7XG4gIFBBVEg6ICckcGF0aCcsXG4gIFBBVFRFUk46ICckdmFsJ1xufTtcblxuY29uc3QgaXNFeHByZXNzaW9uID0gKHF1ZXJ5KSA9PlxuICAhIShxdWVyeVtMb2dpY2FsT3BlcmF0b3IuQU5EXSB8fCBxdWVyeVtMb2dpY2FsT3BlcmF0b3IuT1JdKTtcblxuY29uc3QgaXNQYXRoID0gKHF1ZXJ5KSA9PiAhIXF1ZXJ5W0tleVR5cGUuUEFUSF07XG5cbmNvbnN0IGlzTGVhZiA9IChxdWVyeSkgPT5cbiAgIWlzQXJyYXkocXVlcnkpICYmIGlzT2JqZWN0KHF1ZXJ5KSAmJiAhaXNFeHByZXNzaW9uKHF1ZXJ5KTtcblxuY29uc3QgY29udmVydFRvRXhwbGljaXQgPSAocXVlcnkpID0+ICh7XG4gIFtMb2dpY2FsT3BlcmF0b3IuQU5EXTogT2JqZWN0LmtleXMocXVlcnkpLm1hcCgoa2V5KSA9PiAoe1xuICAgIFtrZXldOiBxdWVyeVtrZXldXG4gIH0pKVxufSk7XG5cbi8vIFdoZW4gYGF1dG9gIGlzIGB0cnVlYCwgdGhlIHBhcnNlIGZ1bmN0aW9uIHdpbGwgaW5mZXIgYW5kIGluaXRpYWxpemUgYW5kIGFkZFxuLy8gdGhlIGFwcHJvcHJpYXRlIGBTZWFyY2hlcmAgaW5zdGFuY2VcbmZ1bmN0aW9uIHBhcnNlKHF1ZXJ5LCBvcHRpb25zLCB7IGF1dG8gPSB0cnVlIH0gPSB7fSkge1xuICBjb25zdCBuZXh0ID0gKHF1ZXJ5KSA9PiB7XG4gICAgbGV0IGtleXMgPSBPYmplY3Qua2V5cyhxdWVyeSk7XG5cbiAgICBjb25zdCBpc1F1ZXJ5UGF0aCA9IGlzUGF0aChxdWVyeSk7XG5cbiAgICBpZiAoIWlzUXVlcnlQYXRoICYmIGtleXMubGVuZ3RoID4gMSAmJiAhaXNFeHByZXNzaW9uKHF1ZXJ5KSkge1xuICAgICAgcmV0dXJuIG5leHQoY29udmVydFRvRXhwbGljaXQocXVlcnkpKVxuICAgIH1cblxuICAgIGlmIChpc0xlYWYocXVlcnkpKSB7XG4gICAgICBjb25zdCBrZXkgPSBpc1F1ZXJ5UGF0aCA/IHF1ZXJ5W0tleVR5cGUuUEFUSF0gOiBrZXlzWzBdO1xuXG4gICAgICBjb25zdCBwYXR0ZXJuID0gaXNRdWVyeVBhdGggPyBxdWVyeVtLZXlUeXBlLlBBVFRFUk5dIDogcXVlcnlba2V5XTtcblxuICAgICAgaWYgKCFpc1N0cmluZyhwYXR0ZXJuKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoTE9HSUNBTF9TRUFSQ0hfSU5WQUxJRF9RVUVSWV9GT1JfS0VZKGtleSkpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG9iaiA9IHtcbiAgICAgICAga2V5SWQ6IGNyZWF0ZUtleUlkKGtleSksXG4gICAgICAgIHBhdHRlcm5cbiAgICAgIH07XG5cbiAgICAgIGlmIChhdXRvKSB7XG4gICAgICAgIG9iai5zZWFyY2hlciA9IGNyZWF0ZVNlYXJjaGVyKHBhdHRlcm4sIG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2JqXG4gICAgfVxuXG4gICAgbGV0IG5vZGUgPSB7XG4gICAgICBjaGlsZHJlbjogW10sXG4gICAgICBvcGVyYXRvcjoga2V5c1swXVxuICAgIH07XG5cbiAgICBrZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSBxdWVyeVtrZXldO1xuXG4gICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICAgIG5vZGUuY2hpbGRyZW4ucHVzaChuZXh0KGl0ZW0pKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbm9kZVxuICB9O1xuXG4gIGlmICghaXNFeHByZXNzaW9uKHF1ZXJ5KSkge1xuICAgIHF1ZXJ5ID0gY29udmVydFRvRXhwbGljaXQocXVlcnkpO1xuICB9XG5cbiAgcmV0dXJuIG5leHQocXVlcnkpXG59XG5cbi8vIFByYWN0aWNhbCBzY29yaW5nIGZ1bmN0aW9uXG5mdW5jdGlvbiBjb21wdXRlU2NvcmUoXG4gIHJlc3VsdHMsXG4gIHsgaWdub3JlRmllbGROb3JtID0gQ29uZmlnLmlnbm9yZUZpZWxkTm9ybSB9XG4pIHtcbiAgcmVzdWx0cy5mb3JFYWNoKChyZXN1bHQpID0+IHtcbiAgICBsZXQgdG90YWxTY29yZSA9IDE7XG5cbiAgICByZXN1bHQubWF0Y2hlcy5mb3JFYWNoKCh7IGtleSwgbm9ybSwgc2NvcmUgfSkgPT4ge1xuICAgICAgY29uc3Qgd2VpZ2h0ID0ga2V5ID8ga2V5LndlaWdodCA6IG51bGw7XG5cbiAgICAgIHRvdGFsU2NvcmUgKj0gTWF0aC5wb3coXG4gICAgICAgIHNjb3JlID09PSAwICYmIHdlaWdodCA/IE51bWJlci5FUFNJTE9OIDogc2NvcmUsXG4gICAgICAgICh3ZWlnaHQgfHwgMSkgKiAoaWdub3JlRmllbGROb3JtID8gMSA6IG5vcm0pXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgcmVzdWx0LnNjb3JlID0gdG90YWxTY29yZTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybU1hdGNoZXMocmVzdWx0LCBkYXRhKSB7XG4gIGNvbnN0IG1hdGNoZXMgPSByZXN1bHQubWF0Y2hlcztcbiAgZGF0YS5tYXRjaGVzID0gW107XG5cbiAgaWYgKCFpc0RlZmluZWQobWF0Y2hlcykpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIG1hdGNoZXMuZm9yRWFjaCgobWF0Y2gpID0+IHtcbiAgICBpZiAoIWlzRGVmaW5lZChtYXRjaC5pbmRpY2VzKSB8fCAhbWF0Y2guaW5kaWNlcy5sZW5ndGgpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHsgaW5kaWNlcywgdmFsdWUgfSA9IG1hdGNoO1xuXG4gICAgbGV0IG9iaiA9IHtcbiAgICAgIGluZGljZXMsXG4gICAgICB2YWx1ZVxuICAgIH07XG5cbiAgICBpZiAobWF0Y2gua2V5KSB7XG4gICAgICBvYmoua2V5ID0gbWF0Y2gua2V5LnNyYztcbiAgICB9XG5cbiAgICBpZiAobWF0Y2guaWR4ID4gLTEpIHtcbiAgICAgIG9iai5yZWZJbmRleCA9IG1hdGNoLmlkeDtcbiAgICB9XG5cbiAgICBkYXRhLm1hdGNoZXMucHVzaChvYmopO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtU2NvcmUocmVzdWx0LCBkYXRhKSB7XG4gIGRhdGEuc2NvcmUgPSByZXN1bHQuc2NvcmU7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdChcbiAgcmVzdWx0cyxcbiAgZG9jcyxcbiAge1xuICAgIGluY2x1ZGVNYXRjaGVzID0gQ29uZmlnLmluY2x1ZGVNYXRjaGVzLFxuICAgIGluY2x1ZGVTY29yZSA9IENvbmZpZy5pbmNsdWRlU2NvcmVcbiAgfSA9IHt9XG4pIHtcbiAgY29uc3QgdHJhbnNmb3JtZXJzID0gW107XG5cbiAgaWYgKGluY2x1ZGVNYXRjaGVzKSB0cmFuc2Zvcm1lcnMucHVzaCh0cmFuc2Zvcm1NYXRjaGVzKTtcbiAgaWYgKGluY2x1ZGVTY29yZSkgdHJhbnNmb3JtZXJzLnB1c2godHJhbnNmb3JtU2NvcmUpO1xuXG4gIHJldHVybiByZXN1bHRzLm1hcCgocmVzdWx0KSA9PiB7XG4gICAgY29uc3QgeyBpZHggfSA9IHJlc3VsdDtcblxuICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICBpdGVtOiBkb2NzW2lkeF0sXG4gICAgICByZWZJbmRleDogaWR4XG4gICAgfTtcblxuICAgIGlmICh0cmFuc2Zvcm1lcnMubGVuZ3RoKSB7XG4gICAgICB0cmFuc2Zvcm1lcnMuZm9yRWFjaCgodHJhbnNmb3JtZXIpID0+IHtcbiAgICAgICAgdHJhbnNmb3JtZXIocmVzdWx0LCBkYXRhKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRhXG4gIH0pXG59XG5cbmNsYXNzIEZ1c2Uge1xuICBjb25zdHJ1Y3Rvcihkb2NzLCBvcHRpb25zID0ge30sIGluZGV4KSB7XG4gICAgdGhpcy5vcHRpb25zID0geyAuLi5Db25maWcsIC4uLm9wdGlvbnMgfTtcblxuICAgIGlmIChcbiAgICAgIHRoaXMub3B0aW9ucy51c2VFeHRlbmRlZFNlYXJjaCAmJlxuICAgICAgIXRydWVcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihFWFRFTkRFRF9TRUFSQ0hfVU5BVkFJTEFCTEUpXG4gICAgfVxuXG4gICAgdGhpcy5fa2V5U3RvcmUgPSBuZXcgS2V5U3RvcmUodGhpcy5vcHRpb25zLmtleXMpO1xuXG4gICAgdGhpcy5zZXRDb2xsZWN0aW9uKGRvY3MsIGluZGV4KTtcbiAgfVxuXG4gIHNldENvbGxlY3Rpb24oZG9jcywgaW5kZXgpIHtcbiAgICB0aGlzLl9kb2NzID0gZG9jcztcblxuICAgIGlmIChpbmRleCAmJiAhKGluZGV4IGluc3RhbmNlb2YgRnVzZUluZGV4KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKElOQ09SUkVDVF9JTkRFWF9UWVBFKVxuICAgIH1cblxuICAgIHRoaXMuX215SW5kZXggPVxuICAgICAgaW5kZXggfHxcbiAgICAgIGNyZWF0ZUluZGV4KHRoaXMub3B0aW9ucy5rZXlzLCB0aGlzLl9kb2NzLCB7XG4gICAgICAgIGdldEZuOiB0aGlzLm9wdGlvbnMuZ2V0Rm4sXG4gICAgICAgIGZpZWxkTm9ybVdlaWdodDogdGhpcy5vcHRpb25zLmZpZWxkTm9ybVdlaWdodFxuICAgICAgfSk7XG4gIH1cblxuICBhZGQoZG9jKSB7XG4gICAgaWYgKCFpc0RlZmluZWQoZG9jKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5fZG9jcy5wdXNoKGRvYyk7XG4gICAgdGhpcy5fbXlJbmRleC5hZGQoZG9jKTtcbiAgfVxuXG4gIHJlbW92ZShwcmVkaWNhdGUgPSAoLyogZG9jLCBpZHggKi8pID0+IGZhbHNlKSB7XG4gICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRoaXMuX2RvY3MubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIGNvbnN0IGRvYyA9IHRoaXMuX2RvY3NbaV07XG4gICAgICBpZiAocHJlZGljYXRlKGRvYywgaSkpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVBdChpKTtcbiAgICAgICAgaSAtPSAxO1xuICAgICAgICBsZW4gLT0gMTtcblxuICAgICAgICByZXN1bHRzLnB1c2goZG9jKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0c1xuICB9XG5cbiAgcmVtb3ZlQXQoaWR4KSB7XG4gICAgdGhpcy5fZG9jcy5zcGxpY2UoaWR4LCAxKTtcbiAgICB0aGlzLl9teUluZGV4LnJlbW92ZUF0KGlkeCk7XG4gIH1cblxuICBnZXRJbmRleCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbXlJbmRleFxuICB9XG5cbiAgc2VhcmNoKHF1ZXJ5LCB7IGxpbWl0ID0gLTEgfSA9IHt9KSB7XG4gICAgY29uc3Qge1xuICAgICAgaW5jbHVkZU1hdGNoZXMsXG4gICAgICBpbmNsdWRlU2NvcmUsXG4gICAgICBzaG91bGRTb3J0LFxuICAgICAgc29ydEZuLFxuICAgICAgaWdub3JlRmllbGROb3JtXG4gICAgfSA9IHRoaXMub3B0aW9ucztcblxuICAgIGxldCByZXN1bHRzID0gaXNTdHJpbmcocXVlcnkpXG4gICAgICA/IGlzU3RyaW5nKHRoaXMuX2RvY3NbMF0pXG4gICAgICAgID8gdGhpcy5fc2VhcmNoU3RyaW5nTGlzdChxdWVyeSlcbiAgICAgICAgOiB0aGlzLl9zZWFyY2hPYmplY3RMaXN0KHF1ZXJ5KVxuICAgICAgOiB0aGlzLl9zZWFyY2hMb2dpY2FsKHF1ZXJ5KTtcblxuICAgIGNvbXB1dGVTY29yZShyZXN1bHRzLCB7IGlnbm9yZUZpZWxkTm9ybSB9KTtcblxuICAgIGlmIChzaG91bGRTb3J0KSB7XG4gICAgICByZXN1bHRzLnNvcnQoc29ydEZuKTtcbiAgICB9XG5cbiAgICBpZiAoaXNOdW1iZXIobGltaXQpICYmIGxpbWl0ID4gLTEpIHtcbiAgICAgIHJlc3VsdHMgPSByZXN1bHRzLnNsaWNlKDAsIGxpbWl0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZm9ybWF0KHJlc3VsdHMsIHRoaXMuX2RvY3MsIHtcbiAgICAgIGluY2x1ZGVNYXRjaGVzLFxuICAgICAgaW5jbHVkZVNjb3JlXG4gICAgfSlcbiAgfVxuXG4gIF9zZWFyY2hTdHJpbmdMaXN0KHF1ZXJ5KSB7XG4gICAgY29uc3Qgc2VhcmNoZXIgPSBjcmVhdGVTZWFyY2hlcihxdWVyeSwgdGhpcy5vcHRpb25zKTtcbiAgICBjb25zdCB7IHJlY29yZHMgfSA9IHRoaXMuX215SW5kZXg7XG4gICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuXG4gICAgLy8gSXRlcmF0ZSBvdmVyIGV2ZXJ5IHN0cmluZyBpbiB0aGUgaW5kZXhcbiAgICByZWNvcmRzLmZvckVhY2goKHsgdjogdGV4dCwgaTogaWR4LCBuOiBub3JtIH0pID0+IHtcbiAgICAgIGlmICghaXNEZWZpbmVkKHRleHQpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBjb25zdCB7IGlzTWF0Y2gsIHNjb3JlLCBpbmRpY2VzIH0gPSBzZWFyY2hlci5zZWFyY2hJbih0ZXh0KTtcblxuICAgICAgaWYgKGlzTWF0Y2gpIHtcbiAgICAgICAgcmVzdWx0cy5wdXNoKHtcbiAgICAgICAgICBpdGVtOiB0ZXh0LFxuICAgICAgICAgIGlkeCxcbiAgICAgICAgICBtYXRjaGVzOiBbeyBzY29yZSwgdmFsdWU6IHRleHQsIG5vcm0sIGluZGljZXMgfV1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0c1xuICB9XG5cbiAgX3NlYXJjaExvZ2ljYWwocXVlcnkpIHtcblxuICAgIGNvbnN0IGV4cHJlc3Npb24gPSBwYXJzZShxdWVyeSwgdGhpcy5vcHRpb25zKTtcblxuICAgIGNvbnN0IGV2YWx1YXRlID0gKG5vZGUsIGl0ZW0sIGlkeCkgPT4ge1xuICAgICAgaWYgKCFub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgIGNvbnN0IHsga2V5SWQsIHNlYXJjaGVyIH0gPSBub2RlO1xuXG4gICAgICAgIGNvbnN0IG1hdGNoZXMgPSB0aGlzLl9maW5kTWF0Y2hlcyh7XG4gICAgICAgICAga2V5OiB0aGlzLl9rZXlTdG9yZS5nZXQoa2V5SWQpLFxuICAgICAgICAgIHZhbHVlOiB0aGlzLl9teUluZGV4LmdldFZhbHVlRm9ySXRlbUF0S2V5SWQoaXRlbSwga2V5SWQpLFxuICAgICAgICAgIHNlYXJjaGVyXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChtYXRjaGVzICYmIG1hdGNoZXMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgaWR4LFxuICAgICAgICAgICAgICBpdGVtLFxuICAgICAgICAgICAgICBtYXRjaGVzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgXVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtdXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBldmFsdWF0ZShjaGlsZCwgaXRlbSwgaWR4KTtcbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGgpIHtcbiAgICAgICAgICByZXMucHVzaCguLi5yZXN1bHQpO1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGUub3BlcmF0b3IgPT09IExvZ2ljYWxPcGVyYXRvci5BTkQpIHtcbiAgICAgICAgICByZXR1cm4gW11cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc1xuICAgIH07XG5cbiAgICBjb25zdCByZWNvcmRzID0gdGhpcy5fbXlJbmRleC5yZWNvcmRzO1xuICAgIGNvbnN0IHJlc3VsdE1hcCA9IHt9O1xuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcblxuICAgIHJlY29yZHMuZm9yRWFjaCgoeyAkOiBpdGVtLCBpOiBpZHggfSkgPT4ge1xuICAgICAgaWYgKGlzRGVmaW5lZChpdGVtKSkge1xuICAgICAgICBsZXQgZXhwUmVzdWx0cyA9IGV2YWx1YXRlKGV4cHJlc3Npb24sIGl0ZW0sIGlkeCk7XG5cbiAgICAgICAgaWYgKGV4cFJlc3VsdHMubGVuZ3RoKSB7XG4gICAgICAgICAgLy8gRGVkdXBlIHdoZW4gYWRkaW5nXG4gICAgICAgICAgaWYgKCFyZXN1bHRNYXBbaWR4XSkge1xuICAgICAgICAgICAgcmVzdWx0TWFwW2lkeF0gPSB7IGlkeCwgaXRlbSwgbWF0Y2hlczogW10gfTtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChyZXN1bHRNYXBbaWR4XSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGV4cFJlc3VsdHMuZm9yRWFjaCgoeyBtYXRjaGVzIH0pID0+IHtcbiAgICAgICAgICAgIHJlc3VsdE1hcFtpZHhdLm1hdGNoZXMucHVzaCguLi5tYXRjaGVzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdHNcbiAgfVxuXG4gIF9zZWFyY2hPYmplY3RMaXN0KHF1ZXJ5KSB7XG4gICAgY29uc3Qgc2VhcmNoZXIgPSBjcmVhdGVTZWFyY2hlcihxdWVyeSwgdGhpcy5vcHRpb25zKTtcbiAgICBjb25zdCB7IGtleXMsIHJlY29yZHMgfSA9IHRoaXMuX215SW5kZXg7XG4gICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuXG4gICAgLy8gTGlzdCBpcyBBcnJheTxPYmplY3Q+XG4gICAgcmVjb3Jkcy5mb3JFYWNoKCh7ICQ6IGl0ZW0sIGk6IGlkeCB9KSA9PiB7XG4gICAgICBpZiAoIWlzRGVmaW5lZChpdGVtKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgbGV0IG1hdGNoZXMgPSBbXTtcblxuICAgICAgLy8gSXRlcmF0ZSBvdmVyIGV2ZXJ5IGtleSAoaS5lLCBwYXRoKSwgYW5kIGZldGNoIHRoZSB2YWx1ZSBhdCB0aGF0IGtleVxuICAgICAga2V5cy5mb3JFYWNoKChrZXksIGtleUluZGV4KSA9PiB7XG4gICAgICAgIG1hdGNoZXMucHVzaChcbiAgICAgICAgICAuLi50aGlzLl9maW5kTWF0Y2hlcyh7XG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICB2YWx1ZTogaXRlbVtrZXlJbmRleF0sXG4gICAgICAgICAgICBzZWFyY2hlclxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKG1hdGNoZXMubGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdHMucHVzaCh7XG4gICAgICAgICAgaWR4LFxuICAgICAgICAgIGl0ZW0sXG4gICAgICAgICAgbWF0Y2hlc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHRzXG4gIH1cbiAgX2ZpbmRNYXRjaGVzKHsga2V5LCB2YWx1ZSwgc2VhcmNoZXIgfSkge1xuICAgIGlmICghaXNEZWZpbmVkKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIFtdXG4gICAgfVxuXG4gICAgbGV0IG1hdGNoZXMgPSBbXTtcblxuICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgdmFsdWUuZm9yRWFjaCgoeyB2OiB0ZXh0LCBpOiBpZHgsIG46IG5vcm0gfSkgPT4ge1xuICAgICAgICBpZiAoIWlzRGVmaW5lZCh0ZXh0KSkge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeyBpc01hdGNoLCBzY29yZSwgaW5kaWNlcyB9ID0gc2VhcmNoZXIuc2VhcmNoSW4odGV4dCk7XG5cbiAgICAgICAgaWYgKGlzTWF0Y2gpIHtcbiAgICAgICAgICBtYXRjaGVzLnB1c2goe1xuICAgICAgICAgICAgc2NvcmUsXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICB2YWx1ZTogdGV4dCxcbiAgICAgICAgICAgIGlkeCxcbiAgICAgICAgICAgIG5vcm0sXG4gICAgICAgICAgICBpbmRpY2VzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB7IHY6IHRleHQsIG46IG5vcm0gfSA9IHZhbHVlO1xuXG4gICAgICBjb25zdCB7IGlzTWF0Y2gsIHNjb3JlLCBpbmRpY2VzIH0gPSBzZWFyY2hlci5zZWFyY2hJbih0ZXh0KTtcblxuICAgICAgaWYgKGlzTWF0Y2gpIHtcbiAgICAgICAgbWF0Y2hlcy5wdXNoKHsgc2NvcmUsIGtleSwgdmFsdWU6IHRleHQsIG5vcm0sIGluZGljZXMgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hdGNoZXNcbiAgfVxufVxuXG5GdXNlLnZlcnNpb24gPSAnNi42LjInO1xuRnVzZS5jcmVhdGVJbmRleCA9IGNyZWF0ZUluZGV4O1xuRnVzZS5wYXJzZUluZGV4ID0gcGFyc2VJbmRleDtcbkZ1c2UuY29uZmlnID0gQ29uZmlnO1xuXG57XG4gIEZ1c2UucGFyc2VRdWVyeSA9IHBhcnNlO1xufVxuXG57XG4gIHJlZ2lzdGVyKEV4dGVuZGVkU2VhcmNoKTtcbn1cblxuZXhwb3J0IHsgRnVzZSBhcyBkZWZhdWx0IH07XG4iXSwibmFtZXMiOlsiaXNBcnJheSIsInZhbHVlIiwiQXJyYXkiLCJnZXRUYWciLCJJTkZJTklUWSIsImJhc2VUb1N0cmluZyIsInJlc3VsdCIsInRvU3RyaW5nIiwiaXNTdHJpbmciLCJpc051bWJlciIsImlzQm9vbGVhbiIsImlzT2JqZWN0TGlrZSIsImlzT2JqZWN0IiwiaXNEZWZpbmVkIiwidW5kZWZpbmVkIiwiaXNCbGFuayIsInRyaW0iLCJsZW5ndGgiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJjYWxsIiwiRVhURU5ERURfU0VBUkNIX1VOQVZBSUxBQkxFIiwiSU5DT1JSRUNUX0lOREVYX1RZUEUiLCJMT0dJQ0FMX1NFQVJDSF9JTlZBTElEX1FVRVJZX0ZPUl9LRVkiLCJrZXkiLCJQQVRURVJOX0xFTkdUSF9UT09fTEFSR0UiLCJtYXgiLCJNSVNTSU5HX0tFWV9QUk9QRVJUWSIsIm5hbWUiLCJJTlZBTElEX0tFWV9XRUlHSFRfVkFMVUUiLCJoYXNPd24iLCJoYXNPd25Qcm9wZXJ0eSIsIktleVN0b3JlIiwiY29uc3RydWN0b3IiLCJrZXlzIiwiX2tleXMiLCJfa2V5TWFwIiwidG90YWxXZWlnaHQiLCJmb3JFYWNoIiwib2JqIiwiY3JlYXRlS2V5Iiwid2VpZ2h0IiwicHVzaCIsImlkIiwiZ2V0Iiwia2V5SWQiLCJ0b0pTT04iLCJKU09OIiwic3RyaW5naWZ5IiwicGF0aCIsInNyYyIsImdldEZuIiwiY3JlYXRlS2V5UGF0aCIsImNyZWF0ZUtleUlkIiwiRXJyb3IiLCJzcGxpdCIsImpvaW4iLCJsaXN0IiwiYXJyIiwiZGVlcEdldCIsImluZGV4IiwiaSIsImxlbiIsIk1hdGNoT3B0aW9ucyIsImluY2x1ZGVNYXRjaGVzIiwiZmluZEFsbE1hdGNoZXMiLCJtaW5NYXRjaENoYXJMZW5ndGgiLCJCYXNpY09wdGlvbnMiLCJpc0Nhc2VTZW5zaXRpdmUiLCJpbmNsdWRlU2NvcmUiLCJzaG91bGRTb3J0Iiwic29ydEZuIiwiYSIsImIiLCJzY29yZSIsImlkeCIsIkZ1enp5T3B0aW9ucyIsImxvY2F0aW9uIiwidGhyZXNob2xkIiwiZGlzdGFuY2UiLCJBZHZhbmNlZE9wdGlvbnMiLCJ1c2VFeHRlbmRlZFNlYXJjaCIsImlnbm9yZUxvY2F0aW9uIiwiaWdub3JlRmllbGROb3JtIiwiZmllbGROb3JtV2VpZ2h0IiwiQ29uZmlnIiwiU1BBQ0UiLCJub3JtIiwibWFudGlzc2EiLCJjYWNoZSIsIk1hcCIsIm0iLCJNYXRoIiwicG93IiwibnVtVG9rZW5zIiwibWF0Y2giLCJoYXMiLCJuIiwicGFyc2VGbG9hdCIsInJvdW5kIiwic2V0IiwiY2xlYXIiLCJGdXNlSW5kZXgiLCJpc0NyZWF0ZWQiLCJzZXRJbmRleFJlY29yZHMiLCJzZXRTb3VyY2VzIiwiZG9jcyIsInJlY29yZHMiLCJzZXRLZXlzIiwiX2tleXNNYXAiLCJjcmVhdGUiLCJkb2MiLCJkb2NJbmRleCIsIl9hZGRTdHJpbmciLCJfYWRkT2JqZWN0IiwiYWRkIiwic2l6ZSIsInJlbW92ZUF0Iiwic3BsaWNlIiwiZ2V0VmFsdWVGb3JJdGVtQXRLZXlJZCIsIml0ZW0iLCJyZWNvcmQiLCJ2IiwiJCIsImtleUluZGV4Iiwic3ViUmVjb3JkcyIsInN0YWNrIiwibmVzdGVkQXJySW5kZXgiLCJwb3AiLCJzdWJSZWNvcmQiLCJrIiwiY3JlYXRlSW5kZXgiLCJteUluZGV4IiwibWFwIiwicGFyc2VJbmRleCIsImRhdGEiLCJjb21wdXRlU2NvcmUkMSIsInBhdHRlcm4iLCJlcnJvcnMiLCJjdXJyZW50TG9jYXRpb24iLCJleHBlY3RlZExvY2F0aW9uIiwiYWNjdXJhY3kiLCJwcm94aW1pdHkiLCJhYnMiLCJjb252ZXJ0TWFza1RvSW5kaWNlcyIsIm1hdGNobWFzayIsImluZGljZXMiLCJzdGFydCIsImVuZCIsIk1BWF9CSVRTIiwic2VhcmNoIiwidGV4dCIsInBhdHRlcm5BbHBoYWJldCIsInBhdHRlcm5MZW4iLCJ0ZXh0TGVuIiwibWluIiwiY3VycmVudFRocmVzaG9sZCIsImJlc3RMb2NhdGlvbiIsImNvbXB1dGVNYXRjaGVzIiwibWF0Y2hNYXNrIiwiaW5kZXhPZiIsImxhc3RCaXRBcnIiLCJmaW5hbFNjb3JlIiwiYmluTWF4IiwibWFzayIsImJpbk1pbiIsImJpbk1pZCIsImZsb29yIiwiZmluaXNoIiwiYml0QXJyIiwiaiIsImNoYXJNYXRjaCIsImNoYXJBdCIsImlzTWF0Y2giLCJjcmVhdGVQYXR0ZXJuQWxwaGFiZXQiLCJjaGFyIiwiQml0YXBTZWFyY2giLCJvcHRpb25zIiwidG9Mb3dlckNhc2UiLCJjaHVua3MiLCJhZGRDaHVuayIsInN0YXJ0SW5kZXgiLCJhbHBoYWJldCIsInJlbWFpbmRlciIsInN1YnN0ciIsInNlYXJjaEluIiwiYWxsSW5kaWNlcyIsInRvdGFsU2NvcmUiLCJoYXNNYXRjaGVzIiwiQmFzZU1hdGNoIiwiaXNNdWx0aU1hdGNoIiwiZ2V0TWF0Y2giLCJtdWx0aVJlZ2V4IiwiaXNTaW5nbGVNYXRjaCIsInNpbmdsZVJlZ2V4IiwiZXhwIiwibWF0Y2hlcyIsIkV4YWN0TWF0Y2giLCJ0eXBlIiwiSW52ZXJzZUV4YWN0TWF0Y2giLCJQcmVmaXhFeGFjdE1hdGNoIiwic3RhcnRzV2l0aCIsIkludmVyc2VQcmVmaXhFeGFjdE1hdGNoIiwiU3VmZml4RXhhY3RNYXRjaCIsImVuZHNXaXRoIiwiSW52ZXJzZVN1ZmZpeEV4YWN0TWF0Y2giLCJGdXp6eU1hdGNoIiwiX2JpdGFwU2VhcmNoIiwiSW5jbHVkZU1hdGNoIiwic2VhcmNoZXJzIiwic2VhcmNoZXJzTGVuIiwiU1BBQ0VfUkUiLCJPUl9UT0tFTiIsInBhcnNlUXVlcnkiLCJxdWVyeSIsImZpbHRlciIsInJlc3VsdHMiLCJxdWVyeUl0ZW0iLCJmb3VuZCIsInNlYXJjaGVyIiwidG9rZW4iLCJNdWx0aU1hdGNoU2V0IiwiU2V0IiwiRXh0ZW5kZWRTZWFyY2giLCJjb25kaXRpb24iLCJfIiwibnVtTWF0Y2hlcyIsInFMZW4iLCJwTGVuIiwicmVnaXN0ZXJlZFNlYXJjaGVycyIsInJlZ2lzdGVyIiwiYXJncyIsImNyZWF0ZVNlYXJjaGVyIiwic2VhcmNoZXJDbGFzcyIsIkxvZ2ljYWxPcGVyYXRvciIsIkFORCIsIk9SIiwiS2V5VHlwZSIsIlBBVEgiLCJQQVRURVJOIiwiaXNFeHByZXNzaW9uIiwiaXNQYXRoIiwiaXNMZWFmIiwiY29udmVydFRvRXhwbGljaXQiLCJwYXJzZSIsImF1dG8iLCJuZXh0IiwiaXNRdWVyeVBhdGgiLCJub2RlIiwiY2hpbGRyZW4iLCJvcGVyYXRvciIsImNvbXB1dGVTY29yZSIsIk51bWJlciIsIkVQU0lMT04iLCJ0cmFuc2Zvcm1NYXRjaGVzIiwicmVmSW5kZXgiLCJ0cmFuc2Zvcm1TY29yZSIsImZvcm1hdCIsInRyYW5zZm9ybWVycyIsInRyYW5zZm9ybWVyIiwiRnVzZSIsIl9rZXlTdG9yZSIsInNldENvbGxlY3Rpb24iLCJfZG9jcyIsIl9teUluZGV4IiwicmVtb3ZlIiwicHJlZGljYXRlIiwiZ2V0SW5kZXgiLCJsaW1pdCIsIl9zZWFyY2hTdHJpbmdMaXN0IiwiX3NlYXJjaE9iamVjdExpc3QiLCJfc2VhcmNoTG9naWNhbCIsInNvcnQiLCJzbGljZSIsImV4cHJlc3Npb24iLCJldmFsdWF0ZSIsIl9maW5kTWF0Y2hlcyIsInJlcyIsImNoaWxkIiwicmVzdWx0TWFwIiwiZXhwUmVzdWx0cyIsInZlcnNpb24iLCJjb25maWciLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/fuse.js@6.6.2/node_modules/fuse.js/dist/fuse.esm.js\n");

/***/ })

};
;